<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Protocol Guide</title>
<style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: #0f1115; color: #f0f0f0; margin: 40px; line-height: 1.6; }
    h1 { color: #4ec9b0; }
    .callout { background: #1a2332; padding: 15px; border-left: 4px solid #4ec9b0; border-radius: 4px; margin: 20px 0; }
    a { color: #66b0ff; }
</style>
</head>
<body>
<h1>Protocol Plugins: An Overview</h1>
<p>Protocol plugins are the heart of the fuzzer. They teach the fuzzer how to speak the language of your target application.</p>

<div class="callout">
    <p>This guide provides a high-level overview of protocol plugins. For a detailed, step-by-step guide on how to create your own, please see the <a href="/core/ui/guides/protocol-authoring-guide.html">Comprehensive Protocol Authoring Guide</a>.</p>
</div>

<h2>What is a Protocol Plugin?</h2>
<p>A protocol plugin is a Python file that defines three key things:</p>
<ul>
    <li><strong>Data Model</strong>: The structure of the protocol's messages.</li>
    <li><strong>State Model</strong>: The sequence of states the protocol goes through (e.g., authentication, data transfer).</li>
    <li><strong>Response Validator</strong>: A "logic oracle" to detect non-crash bugs.</li>
</ul>

<h2>Why are Plugins Important?</h2>
<p>Without a plugin, the fuzzer would only be able to send random bytes to the target. This is unlikely to get past the initial parsing stages of the application. A well-defined plugin allows the fuzzer to:</p>
<ul>
    <li>Generate valid, state-aware messages.</li>
    <li>Bypass initial validation and reach deeper, more interesting code paths.</li>
    <li>Understand the protocol's "grammar" and make intelligent mutations.</li>
</ul>

<h2>Next Steps</h2>
<p>Ready to build your own plugin? Head over to the <a href="/core/ui/guides/protocol-authoring-guide.html">Comprehensive Protocol Authoring Guide</a> to get started.</p>
</body>
</html>
