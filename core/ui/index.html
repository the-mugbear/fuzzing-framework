<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proprietary Protocol Fuzzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
        }

        .help-btn {
            background: #444;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .help-btn:hover {
            background: #555;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
        }

        .nav-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .nav-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: #252525;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }

        .card h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #fff;
        }

        .insight-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .insight-panel {
            background: #1b1b1b;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .insight-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .insight-panel-header h3 {
            font-size: 16px;
            color: #fff;
        }

        .insight-meta {
            font-size: 12px;
            color: #777;
        }

        .protocol-diagram {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .protocol-blocks {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .protocol-block {
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px;
            background: #161616;
        }

        .protocol-block.fuzzable {
            border-color: #0f8ecb;
            box-shadow: inset 0 0 0 1px rgba(15, 142, 203, 0.2);
        }

        .protocol-block.locked {
            opacity: 0.8;
        }

        .protocol-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .block-name {
            font-weight: 600;
            color: #f5f5f5;
        }

        .block-type {
            font-size: 12px;
            color: #9ac7ff;
            background: rgba(0, 102, 204, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .block-meta {
            font-size: 12px;
            color: #aaa;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .block-flags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .flag-pill {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 999px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #bbb;
        }

        .flag-pill.behavior {
            border-color: #0066cc;
            color: #66b0ff;
        }

        .protocol-legend {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #888;
        }

        .protocol-legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .legend-dot.fuzzable {
            background: #0f8ecb;
        }

        .legend-dot.locked {
            background: #555;
        }

        .seed-preview {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 12px;
        }

        .seed-chip {
            border: 1px dashed #333;
            padding: 8px;
            border-radius: 6px;
            background: #111;
        }

        .seed-chip span {
            font-size: 12px;
            color: #aaa;
            display: block;
            margin-bottom: 4px;
        }

        .seed-chip code {
            display: block;
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            overflow-x: auto;
        }

        .mutation-previews {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .sample-case {
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px;
            background: #121212;
        }

        .sample-case-header {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 6px;
            color: #ddd;
        }

        .sample-case-body {
            font-size: 12px;
            color: #bbb;
            line-height: 1.5;
        }

        .message-preview {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 11px;
        }

        .message-segment {
            background: #1e1e1e;
            border-radius: 4px;
            padding: 4px 6px;
            border: 1px solid #2e2e2e;
        }

        .message-segment.mutated {
            border-color: #0f8ecb;
            color: #66b0ff;
        }

        .computed-badge {
            font-size: 10px;
            color: #4a9eff;
            margin-left: 4px;
            opacity: 0.8;
        }

        .field-breakdown {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .field-item {
            padding: 4px 8px;
            background: #1a1a1a;
            border-radius: 3px;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .field-item.mutated {
            background: #1a2530;
            border-left: 2px solid #0f8ecb;
        }

        .hex-preview {
            padding: 8px;
            background: #0a0a0a;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #888;
            overflow-x: auto;
            white-space: nowrap;
        }

        .coach-panel {
            margin-top: 20px;
        }

        .coach-checklist {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .coach-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #333;
            background: #111;
            font-size: 13px;
        }

        .coach-label {
            font-weight: 600;
            color: #eee;
        }

        .coach-message {
            font-size: 12px;
            color: #aaa;
        }

        .coach-status {
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 700;
        }

        .coach-status.ready {
            background: rgba(0, 170, 0, 0.2);
            color: #6fff80;
        }

        .coach-status.warn {
            background: rgba(255, 204, 0, 0.15);
            color: #ffdd66;
        }

        .coach-status.error {
            background: rgba(204, 0, 0, 0.2);
            color: #ff8f8f;
        }

        .coach-status.pending {
            background: rgba(153, 153, 153, 0.2);
            color: #ccc;
        }

        .coach-tip {
            font-size: 12px;
            color: #9ac7ff;
            border-top: 1px dashed #333;
            padding-top: 10px;
        }

        .empty-state {
            color: #666;
            font-size: 13px;
        }

        .guide-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .guide-links a {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 6px;
            color: #66b0ff;
            text-decoration: none;
            font-size: 14px;
        }

        .guide-links a:hover {
            background: #252525;
            border-color: #0066cc;
        }

        .behavior-summary {
            margin-top: 15px;
            padding: 12px;
            background: #1f1f1f;
            border: 1px dashed #333;
            border-radius: 6px;
            font-size: 13px;
            color: #cbcaca;
        }

        .behavior-summary ul {
            margin-top: 8px;
            margin-left: 18px;
        }

        .behavior-summary li {
            margin-bottom: 4px;
        }

        .card-description {
            color: #888;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-left: 3px solid #0066cc;
            border-radius: 4px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .help-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: #444;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            cursor: help;
            color: #aaa;
        }

        .help-icon:hover {
            background: #0066cc;
            color: white;
        }

        .field-help {
            font-size: 12px;
            color: #666;
            margin-top: 3px;
            font-style: italic;
        }

        input, select {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #0066cc;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        button:hover {
            background: #0052a3;
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
        }

        button.secondary {
            background: #444;
        }

        button.secondary:hover {
            background: #555;
        }

        button.danger {
            background: #cc0000;
        }

        button.danger:hover {
            background: #990000;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-idle { background: #444; }
        .status-running { background: #00aa00; animation: pulse 2s infinite; }
        .status-completed { background: #0066cc; }
        .status-failed { background: #cc0000; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .session-item {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .session-info {
            flex-grow: 1;
        }

        .session-actions {
            display: flex;
            gap: 10px;
        }

        .session-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }

        .session-detail {
            font-size: 12px;
        }

        .session-detail-label {
            color: #666;
        }

        .session-detail-value {
            color: #fff;
            font-weight: 600;
        }

        .error {
            background: #cc0000;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .success {
            background: #00aa00;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .info {
            background: #0066cc;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .help-section {
            background: #252525;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .help-section h3 {
            color: #0066cc;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .help-section h4 {
            color: #fff;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .help-section p {
            color: #aaa;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .help-section ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .help-section li {
            color: #aaa;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .code-block {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #0066cc;
            margin: 15px 0;
            overflow-x: auto;
        }

        .code-block pre {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .highlight {
            background: #0066cc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: #252525;
            border-radius: 8px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }

        .modal-title {
            font-size: 24px;
            color: #fff;
        }

        .modal-close {
            background: #444;
            border: none;
            color: #fff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        .modal-close:hover {
            background: #cc0000;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .step-indicator {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #0066cc;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            color: white;
            font-weight: bold;
            margin-right: 10px;
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-item:hover {
            background: #252525;
            border-color: #0066cc;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
            cursor: pointer;
        }

        .checkbox-item label {
            margin: 0;
            cursor: pointer;
            flex-grow: 1;
            color: #e0e0e0;
            font-size: 13px;
        }

        .checkbox-item.checked {
            background: #1a3a5a;
            border-color: #0066cc;
        }

        .mutator-description {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1>Proprietary Protocol Fuzzer</h1>
                <p class="subtitle">Portable & Extensible Network Protocol Security Testing Framework</p>
            </div>
            <button class="help-btn" onclick="showHelp()">Help & Guides</button>
        </header>

        <div id="messages"></div>

        <!-- Navigation Tabs -->
        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="dashboard" onclick="switchTab('dashboard', this)">Dashboard</button>
            <button class="nav-tab" data-tab="plugin-debug" onclick="switchTab('plugin-debug', this)">Plugin Debugger</button>
            <button class="nav-tab" data-tab="help" onclick="switchTab('help', this)">Getting Started</button>
            <button class="nav-tab" data-tab="protocol-guide" onclick="switchTab('protocol-guide', this)">Protocol Guide</button>
            <button class="nav-tab" data-tab="mutation-guide" onclick="switchTab('mutation-guide', this)">Mutation Guide</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard-tab" class="tab-content active">
            <div class="grid">
                <!-- Create Session -->
                <div class="card">
                    <h2>Create Fuzzing Session</h2>
                    <div class="card-description">
                        <strong>Step 1:</strong> Configure your fuzzing campaign. Select a protocol plugin,
                        specify the target host and port, then create a session. The fuzzer will use the
                        protocol's seed corpus and mutation strategies to generate test cases.
                    </div>
                    <form id="createSessionForm">
                        <div class="form-group">
                            <label for="protocol">
                                Protocol Plugin
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Protocol plugins define the message structure (data model) and
                                        state machine for your target protocol. Custom plugins can be
                                        added to the core/plugins/ directory.
                                    </span>
                                </span>
                            </label>
                            <select id="protocol" required>
                                <option value="">Loading protocols...</option>
                            </select>
                            <div class="field-help">Choose a protocol that matches your target application</div>
                        </div>
                        <div class="form-group">
                            <label for="targetHost">
                                Target Host
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Hostname or IP address of the target server.
                                        <br><br>
                                        <strong>Docker networking:</strong><br>
                                        • Use 'target' for SimpleTCP test server<br>
                                        • Use '172.17.0.1' (Linux) to reach host from container<br>
                                        • Use 'host.docker.internal' (Mac/Windows) to reach host<br>
                                        • 'localhost' only works if Core is NOT in Docker
                                    </span>
                                </span>
                            </label>
                            <input type="text" id="targetHost" value="target" required>
                            <div class="field-help">
                                <strong>Docker:</strong> Use 'target' for test server, or '172.17.0.1' to reach host.
                                <strong>Local:</strong> Use 'localhost' or IP address.
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="targetPort">
                                Target Port
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        TCP port number where your target service is listening.
                                        Common ports: 80 (HTTP), 443 (HTTPS), 9999 (SimpleTCP test server).
                                    </span>
                                </span>
                            </label>
                            <input type="number" id="targetPort" value="9999" required min="1" max="65535">
                            <div class="field-help">Port number between 1-65535</div>
                        </div>
                        <div class="form-group">
                            <label for="rateLimit">
                                Rate Limit (tests/second)
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Maximum number of test cases to execute per second.
                                        Lower values give the target more time to process each input
                                        and make it easier to manually observe behavior.
                                        Set to 0 for unlimited (maximum throughput).
                                        Recommended: 10-100 for manual observation, 0 for maximum speed.
                                    </span>
                                </span>
                            </label>
                            <input type="number" id="rateLimit" value="0" min="0" max="10000" step="1">
                            <div class="field-help">0 = unlimited, 1-10000 = tests per second. Lower values help prevent dropped connections.</div>
                        </div>
                        <div class="form-group">
                            <label>
                                Mutation Mode
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Controls how test cases are mutated:
                                        • Structure-Aware: Respects protocol grammar, auto-fixes lengths/checksums (~90% valid messages)
                                        • Byte-Level: Traditional bit/byte flips, finds parser bugs (~5% valid messages)
                                        • Hybrid: Mix of both (recommended) - gets deep code coverage + parser bugs
                                    </span>
                                </span>
                            </label>
                            <div style="margin-top: 10px;">
                                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="radio" name="mutationMode" value="hybrid" checked onchange="updateMutationModeUI()">
                                        <span>Hybrid (Recommended)</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="radio" name="mutationMode" value="structure_aware" onchange="updateMutationModeUI()">
                                        <span>Structure-Aware Only</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="radio" name="mutationMode" value="byte_level" onchange="updateMutationModeUI()">
                                        <span>Byte-Level Only</span>
                                    </label>
                                </div>
                            </div>
                            <div id="hybridWeightControl" style="margin-top: 15px; padding: 10px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px;">
                                <label for="structureAwareWeight" style="display: block; margin-bottom: 8px;">
                                    Structure-Aware Weight: <span id="weightValue">70</span>%
                                    <span class="tooltip">
                                        <span class="help-icon">?</span>
                                        <span class="tooltiptext">
                                            Percentage of mutations that use structure-aware approach.
                                            Higher = more valid messages and deeper code coverage.
                                            Lower = more parser testing and edge case discovery.
                                        </span>
                                    </span>
                                </label>
                                <input type="range" id="structureAwareWeight" min="0" max="100" value="70"
                                       oninput="document.getElementById('weightValue').textContent = this.value"
                                       style="width: 100%; cursor: pointer;">
                                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-top: 5px;">
                                    <span>0% (All Byte-Level)</span>
                                    <span>50% (Balanced)</span>
                                    <span>100% (All Structure-Aware)</span>
                                </div>
                            </div>
                            <div class="field-help">Structure-aware mutations respect protocol grammar and auto-fix dependent fields</div>
                        </div>
                        <div class="form-group">
                            <label>
                                Mutation Strategies
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Select which mutation strategies to enable for this session.
                                        Each strategy targets different vulnerability classes.
                                        See the "Mutation Guide" tab for detailed descriptions.
                                        All strategies are enabled by default.
                                    </span>
                                </span>
                            </label>
                            <div class="checkbox-group">
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_bitflip')">
                                    <input type="checkbox" id="mutator_bitflip" checked>
                                    <label for="mutator_bitflip">
                                        Bit Flip
                                        <span class="mutator-description">Flips individual bits (0→1, 1→0)</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_byteflip')">
                                    <input type="checkbox" id="mutator_byteflip" checked>
                                    <label for="mutator_byteflip">
                                        Byte Flip
                                        <span class="mutator-description">Replaces bytes with random values</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_arithmetic')">
                                    <input type="checkbox" id="mutator_arithmetic" checked>
                                    <label for="mutator_arithmetic">
                                        Arithmetic
                                        <span class="mutator-description">Integer overflow/underflow tests</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_interesting')">
                                    <input type="checkbox" id="mutator_interesting" checked>
                                    <label for="mutator_interesting">
                                        Interesting Values
                                        <span class="mutator-description">Boundary values (0, MAX_INT, etc.)</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_havoc')">
                                    <input type="checkbox" id="mutator_havoc" checked>
                                    <label for="mutator_havoc">
                                        Havoc
                                        <span class="mutator-description">Aggressive insert/delete/shuffle</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_splice')">
                                    <input type="checkbox" id="mutator_splice" checked>
                                    <label for="mutator_splice">
                                        Splice
                                        <span class="mutator-description">Combines different seed inputs</span>
                                    </label>
                                </div>
                            </div>
                            <div class="field-help">At least one mutator must be selected</div>
                        </div>
                        <button type="submit">Create Session</button>
                    </form>
                    <div class="field-help">
                        Need protocol blueprints, corpus previews, or readiness tips? Switch to the
                        <strong>Plugin Debugger</strong> tab to pick a protocol for deep inspection without
                        altering the session form.
                    </div>
                </div>

                <!-- System Status -->
                <div class="card">
                    <h2>System Status</h2>
                    <div class="card-description">
                        <strong>Live Metrics:</strong> Real-time overview of fuzzing activity.
                        Active sessions show running fuzzing campaigns. Seeds are test inputs from
                        protocol plugins. Findings are potential vulnerabilities detected by the oracles.
                    </div>
                    <div class="stats">
                        <div class="stat tooltip">
                            <div class="stat-value" id="activeSessions">0</div>
                            <div class="stat-label">Active Sessions</div>
                            <span class="tooltiptext">
                                Number of fuzzing sessions currently running. Each session targets
                                a specific protocol/host combination and continuously generates
                                test cases. Multiple sessions can run concurrently.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalSeeds">0</div>
                            <div class="stat-label">Corpus Seeds</div>
                            <span class="tooltiptext">
                                Number of seed inputs in the corpus. Seeds are valid protocol messages
                                used as starting points for mutation. More diverse seeds = better
                                code coverage. Seeds come from protocol plugins or manual uploads.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalFindings">0</div>
                            <div class="stat-label">Findings</div>
                            <span class="tooltiptext">
                                Number of potential vulnerabilities discovered. Findings include
                                crashes, hangs, and logical failures. Each finding is saved with
                                full reproduction data in data/crashes/ directory. Findings are
                                persisted across restarts.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalTests">0</div>
                            <div class="stat-label">Total Tests</div>
                            <span class="tooltiptext">
                                Cumulative test cases executed across all sessions. Each test sends
                                one mutated input to the target. Higher numbers indicate more
                                thorough fuzzing. Typical rate: 100-1000 tests/sec depending on
                                target response time.
                            </span>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Active Sessions -->
            <div class="card">
                <h2>Fuzzing Sessions</h2>
                <div class="card-description">
                    <strong>Session Management:</strong> Monitor and control your fuzzing campaigns. Each session
                    represents an independent fuzzing run targeting a specific protocol/host combination.
                    Click <strong>Start</strong> to begin sending mutated test cases to the target. The fuzzer
                    will continuously generate inputs using various mutation strategies and report any crashes,
                    hangs, or anomalies detected by the intelligent oracles.
                </div>
                <div id="sessions" class="loading">Loading sessions...</div>
            </div>
        </div>

        <!-- Plugin Debugger Tab -->
        <div id="plugin-debug-tab" class="tab-content">
            <div class="card">
                <h2>Protocol Plugin Debugger</h2>
                <div class="card-description">
                    Purpose-built diagnostics for protocol authors. Inspect protocol blueprints, seed
                    corpora, mutation previews, and readiness checks without cluttering the primary
                    session dashboard. Use the selector below to pick which plugin to visualize—the
                    session form stays untouched.
                </div>
                <div class="form-group">
                    <label for="pluginDebugProtocol">
                        Protocol Plugin (Debugger)
                        <span class="tooltip">
                            <span class="help-icon">?</span>
                            <span class="tooltiptext">
                                Choose which plugin to visualize. This selection only affects the
                                debugger panels—session creation remains independent.
                            </span>
                        </span>
                    </label>
                    <select id="pluginDebugProtocol">
                        <option value="">Select a protocol to inspect…</option>
                    </select>
                    <div class="field-help">Debugger data updates when you pick a protocol here.</div>
                </div>
                <div id="behaviorSummary" class="behavior-summary">
                    Select a protocol to view automatic field behaviors.
                </div>
                <div class="insight-grid">
                    <div class="insight-panel">
                        <div class="insight-panel-header">
                            <h3>Protocol Blueprint</h3>
                            <span id="protocolBlueprintMeta" class="insight-meta"></span>
                        </div>
                        <div class="protocol-legend">
                            <span><span class="legend-dot fuzzable"></span>Fuzzable</span>
                            <span><span class="legend-dot locked"></span>Locked/derived</span>
                        </div>
                        <div id="protocolDiagram" class="protocol-diagram empty-state">
                            Select a protocol to visualize its blocks.
                        </div>
                    </div>
                    <div class="insight-panel">
                        <div class="insight-panel-header">
                            <h3>Test Case Explorer</h3>
                            <span id="sampleCorpusMeta" class="insight-meta"></span>
                        </div>
                        <div class="seed-preview" id="seedSampleList">
                            Provide seeds inside your plugin to preview baseline requests.
                        </div>
                        <div class="mutation-previews" id="mutationPreviewList">
                            Select a protocol to generate sample mutation plans.
                        </div>
                    </div>
                </div>
                <div class="insight-panel coach-panel">
                    <div class="insight-panel-header">
                        <h3>Configuration Coach</h3>
                    </div>
                    <div id="configurationCoach" class="coach-checklist">
                        Fill in your target details to receive readiness feedback.
                    </div>
                </div>
            </div>
        </div>

        <!-- Help Tab -->
        <div id="help-tab" class="tab-content">
            <div class="help-section">
                <h3>Getting Started with Protocol Fuzzing</h3>

                <h4><span class="step-indicator">1</span>Understanding the Dashboard</h4>
                <p>
                    The dashboard is your control center for fuzzing campaigns. Here's what each section does:
                </p>
                <ul>
                    <li><strong>Create Fuzzing Session:</strong> Configure a new fuzzing campaign by selecting a protocol, target host, and port.</li>
                    <li><strong>System Status:</strong> Real-time metrics showing active sessions, corpus size, findings, and total tests executed.</li>
                    <li><strong>Fuzzing Sessions:</strong> Manage running campaigns - start, stop, and monitor progress.</li>
                </ul>

                <h4><span class="step-indicator">2</span>Creating Your First Session</h4>
                <p>To start fuzzing:</p>
                <ul>
                    <li>Select a <strong>Protocol</strong> from the dropdown (e.g., "simple_tcp" for testing)</li>
                    <li>Enter the <strong>Target Host</strong> - use "target" for the Docker test server, or "localhost" for local testing</li>
                    <li>Specify the <strong>Target Port</strong> - the default SimpleTCP test server uses port 9999</li>
                    <li>Click <strong>"Create Session"</strong> to initialize the fuzzing campaign</li>
                    <li>Once created, click <strong>"Start"</strong> to begin fuzzing</li>
                </ul>

                <h4><span class="step-indicator">3</span>Monitoring Results</h4>
                <p>
                    As the fuzzer runs, watch for these key metrics:
                </p>
                <ul>
                    <li><strong>Tests:</strong> Number of mutated inputs sent to the target</li>
                    <li><strong>Crashes:</strong> Detected program crashes or connection failures</li>
                    <li><strong>Hangs:</strong> Timeouts indicating the target stopped responding</li>
                    <li><strong>Anomalies:</strong> Unexpected behavior detected by the validator oracles</li>
                </ul>

                <h4><span class="step-indicator">4</span>Understanding the Fuzzing Process</h4>
                <p>
                    The fuzzer operates in several stages:
                </p>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;"><strong>Seed Selection:</strong> The fuzzer starts with seed inputs from the protocol plugin</li>
                    <li style="margin-bottom: 10px;"><strong>Mutation:</strong> Multiple mutation strategies (bit flips, byte replacements, boundary values) create variations</li>
                    <li style="margin-bottom: 10px;"><strong>Execution:</strong> Mutated inputs are sent to the target via TCP connections</li>
                    <li style="margin-bottom: 10px;"><strong>Monitoring:</strong> Intelligent oracles watch for crashes, hangs, and logical failures</li>
                    <li style="margin-bottom: 10px;"><strong>Reporting:</strong> Findings are saved with full reproducers for analysis</li>
                </ol>

                <h4><span class="step-indicator">5</span>Testing with the SimpleTCP Server</h4>
                <p>
                    The included SimpleTCP test server has intentional vulnerabilities for demonstration:
                </p>
                <div class="code-block">
                    <pre># View target logs to see fuzzing in action
docker-compose logs -f target

# You'll see:
[+] Connection from (172.20.0.3, ...)
[-] Invalid magic: b'\x7f\xffCP'  ← Mutated headers
[+] Command: 0x91, Length: 4      ← Fuzzed commands</pre>
                </div>

                <h4><span class="step-indicator">6</span>Data Types & Size Planning</h4>
                <p>
                    Plugins support a variety of field encodings. Match the data type to the on-the-wire
                    representation to keep the mutator output valid:
                </p>
                <ul>
                    <li><strong>uint8/uint16/uint32/uint64:</strong> 1-, 2-, 4-, or 8-byte unsigned integers. Specify <code>endian</code> for values wider than 1 byte.</li>
                    <li><strong>int16/int32:</strong> Signed integer forms for targets that expect negative offsets or lengths.</li>
                    <li><strong>bytes:</strong> Raw byte buffers; pair with <code>size</code> for fixed headers or <code>max_size</code> for fuzzable blobs.</li>
                    <li><strong>ascii</strong> / <strong>utf8</strong> strings:</strong> Useful for command verbs or keywords; set <code>max_size</code> to bound mutations.</li>
                    <li><strong>bits</strong> or flag fields:</strong> Model tightly packed control bits using <code>type: "bits"</code> with a <code>bit_length</code> to keep masks aligned.</li>
                </ul>
                <p>
                    Size tips: align multi-byte fields on natural boundaries (2, 4, 8) to match target structs, mark checksum or length holders with
                    <code>is_size_field</code> / <code>size_of</code>, and cap variable payloads with realistic <code>max_size</code> limits so the engine stays performant.
                </p>

                <h4><span class="step-indicator">7</span>Endianness Refresher</h4>
                <p>
                    Network software often mixes big- and little-endian integers. In plugins, set <code>endian: "big"</code> for network byte order (most significant byte first)
                    or <code>endian: "little"</code> for little-endian targets such as many Windows services. Fields without an explicit setting default to little-endian.
                    When a message embeds both styles, declare them per block so the blueprint, behaviors, and mutators keep each field consistent.
                </p>

                <h4><span class="step-indicator">8</span>Next Steps</h4>
                <ul>
                    <li>Check the <strong>"Protocol Guide"</strong> tab to learn how to create custom protocol plugins</li>
                    <li>Read the <strong>"Mutation Guide"</strong> tab to understand test case generation strategies</li>
                    <li>View <code>QUICKSTART.md</code> for Docker deployment and local testing instructions</li>
                    <li>Examine findings in the <code>data/crashes/</code> directory</li>
                </ul>
            </div>
        </div>

        <!-- Protocol Creation Guide Tab -->
        <div id="protocol-guide-tab" class="tab-content">
            <div class="help-section">
                <h3>Creating Custom Protocol Plugins</h3>

                <p>
                    Protocol plugins are simple Python files that define your target protocol's structure and behavior.
                    The fuzzer uses this information to generate intelligent test cases.
                </p>

                <h4>Plugin Architecture</h4>
                <p>Each plugin consists of three main components:</p>
                <ul>
                    <li><strong>Data Model:</strong> Defines message structure (headers, fields, data types)</li>
                    <li><strong>State Model:</strong> Defines protocol state machine and transitions</li>
                    <li><strong>Validator (Optional):</strong> Custom logic to detect logical failures</li>
                </ul>

                <h4>Step 1: Create the Plugin File</h4>
                <p>Create a new file in <code>core/plugins/your_protocol.py</code>:</p>

                <div class="code-block">
                    <pre>"""
My Custom Protocol Plugin
Implements fuzzing for MyProtocol v1.0
"""

__version__ = "1.0.0"

# Required: Data Model
data_model = {
    "name": "MyProtocol",
    "description": "Custom protocol for MyApp",

    # Define message structure as blocks
    "blocks": [
        {
            "name": "magic",           # Field identifier
            "type": "bytes",           # Data type
            "size": 4,                 # Fixed size in bytes
            "default": b"MYPK",        # Default value
            "mutable": False           # Don't mutate (for magic headers)
        },
        {
            "name": "length",
            "type": "uint32",          # 32-bit unsigned integer
            "endian": "big",           # big or little endian
            "is_size_field": True,     # This field indicates data size
            "size_of": "payload"       # References another field
        },
        {
            "name": "command",
            "type": "uint8",           # 8-bit unsigned integer
            "values": {                # Known command codes
                0x01: "CONNECT",
                0x02: "DATA",
                0x03: "DISCONNECT"
            }
        },
        {
            "name": "payload",
            "type": "bytes",
            "max_size": 1024,          # Maximum size for mutation
            "default": b""
        }
    ],

    # Seed corpus: example messages for fuzzing
    "seeds": [
        b"MYPK\x00\x00\x00\x05\x01HELLO",
        b"MYPK\x00\x00\x00\x04\x02DATA",
        b"MYPK\x00\x00\x00\x00\x03"
    ]
}

# Required: State Model
state_model = {
    "initial_state": "INIT",

    # Define protocol states
    "states": ["INIT", "CONNECTED", "AUTHENTICATED", "CLOSED"],

    # Define state transitions
    "transitions": [
        {
            "from": "INIT",
            "to": "CONNECTED",
            "trigger": "connect",
            "message_type": "CONNECT",
            "expected_response": "CONNECT_OK"
        },
        {
            "from": "CONNECTED",
            "to": "AUTHENTICATED",
            "trigger": "authenticate",
            "message_type": "AUTH",
            "expected_response": "AUTH_OK"
        },
        {
            "from": "AUTHENTICATED",
            "to": "AUTHENTICATED",
            "trigger": "data_exchange",
            "message_type": "DATA"
        },
        {
            "from": "AUTHENTICATED",
            "to": "CLOSED",
            "trigger": "disconnect",
            "message_type": "DISCONNECT"
        }
    ]
}

# Optional: Custom Response Validator
def validate_response(response: bytes) -> bool:
    """
    Application-specific response validation.

    This is your "Specification Oracle" - check for logical
    errors that wouldn't cause a crash but violate protocol rules.

    Args:
        response: Raw response bytes from target

    Returns:
        True if response is valid, False if logical error detected

    Raises:
        ValueError: To flag as logical failure with description
    """
    if len(response) < 4:
        return False

    # Verify magic header
    if response[:4] != b"MYPK":
        return False

    # Example: Check for application-specific errors
    if len(response) > 8:
        command = response[8]

        # Error response should never happen in normal flow
        if command == 0xFF:
            return False

        # Check for impossible states
        # Example: Balance should never be negative in financial protocol
        # if response_type == "BALANCE" and parse_balance(response) < 0:
        #     raise ValueError("Negative balance detected - logic bug!")

    return True</pre>
                </div>

                <h4>Step 2: Field Types Reference</h4>
                <p>Available field types for the data model:</p>
                <ul>
                    <li><code>bytes</code> - Raw byte array (requires <code>size</code> or <code>max_size</code>)</li>
                    <li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> - Unsigned integers</li>
                    <li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> - Signed integers</li>
                    <li><code>string</code> - UTF-8 text (specify <code>encoding</code>)</li>
                </ul>

                <h4>Step 3: Advanced Features</h4>
                <p>Mark fields for special handling:</p>
                <ul>
                    <li><code>mutable: False</code> - Prevent fuzzer from mutating this field (use for magic headers)</li>
                    <li><code>is_size_field: True</code> - This field specifies another field's length</li>
                    <li><code>size_of: "fieldname"</code> - Link size field to data field</li>
                    <li><code>values: {}</code> - Dictionary of known/valid values for documentation</li>
                </ul>

                <h4>Field Behavior Operations (Auto-Update Fields)</h4>
                <p>
                    You can define automatic operations that are applied to fields before each message is sent.
                    This is useful for sequence numbers, timestamps, checksums, and other dynamic fields.
                </p>
                <p><strong>Available Operations:</strong></p>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">1. Increment Operation</h4>
                <p style="margin-left: 20px;">
                    Automatically increments the field value by a fixed step on each send. Perfect for sequence numbers, packet IDs, or counters.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "sequence_number",
    "type": "uint32",
    "behavior": {
        "operation": "increment",
        "step": 1,              // How much to add (default: 1)
        "start": 0              // Starting value (optional)
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>step</code>: Amount to increment each time (default: 1)</li>
                    <li><code>start</code>: Initial value (optional, uses field default if not specified)</li>
                    <li><strong>Example:</strong> Message 1: seq=0, Message 2: seq=1, Message 3: seq=2, ...</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">2. Add Constant Operation</h4>
                <p style="margin-left: 20px;">
                    Adds a constant value to the field before sending. Useful for applying offsets or adjustments.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "adjusted_value",
    "type": "uint16",
    "behavior": {
        "operation": "add_constant",
        "value": 100            // Value to add before sending
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>value</code>: Constant to add to field value before each send</li>
                    <li><strong>Example:</strong> If field contains 50, sends 150 (50 + 100)</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">3. Timestamp Operation</h4>
                <p style="margin-left: 20px;">
                    Automatically sets the field to current Unix timestamp. Essential for time-sensitive protocols.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "timestamp",
    "type": "uint64",
    "behavior": {
        "operation": "timestamp",
        "format": "unix_seconds"   // or "unix_milliseconds"
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>format</code>: "unix_seconds" or "unix_milliseconds"</li>
                    <li><strong>Example:</strong> Each message gets current time: 1699123456</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">4. Random Operation</h4>
                <p style="margin-left: 20px;">
                    Generates a random value within specified range. Useful for nonces, random IDs, or varying test data.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "nonce",
    "type": "uint32",
    "behavior": {
        "operation": "random",
        "min": 0,               // Minimum value (default: 0)
        "max": 4294967295       // Maximum value (default: type max)
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>min</code>: Minimum random value (inclusive)</li>
                    <li><code>max</code>: Maximum random value (inclusive)</li>
                    <li><strong>Example:</strong> Each message gets random value: 1847562, 9234512, ...</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">5. Checksum/CRC Operation</h4>
                <p style="margin-left: 20px;">
                    Calculates checksum over specified message fields. Keeps integrity checks valid even with mutations.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "checksum",
    "type": "uint32",
    "behavior": {
        "operation": "checksum",
        "algorithm": "crc32",      // crc32, crc16, md5, sha256, etc.
        "fields": ["payload"],     // Fields to include in calculation
        "offset": 0                // Where to start calculation (optional)
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>algorithm</code>: crc32, crc16, adler32, md5, sha256, etc.</li>
                    <li><code>fields</code>: Array of field names to include in checksum</li>
                    <li><code>offset</code>: Byte offset where calculation starts (optional)</li>
                </ul>

                <h4 style="margin-top: 15px;">Complete Example with Behaviors</h4>
                <div class="code-block">
                    <pre>data_model = {
    "name": "AdvancedProtocol",
    "blocks": [
        {
            "name": "magic",
            "type": "bytes",
            "size": 4,
            "default": b"ADVP",
            "mutable": False
        },
        {
            "name": "sequence",
            "type": "uint32",
            "behavior": {
                "operation": "increment",
                "step": 1
            }
        },
        {
            "name": "timestamp",
            "type": "uint64",
            "behavior": {
                "operation": "timestamp",
                "format": "unix_seconds"
            }
        },
        {
            "name": "nonce",
            "type": "uint32",
            "behavior": {
                "operation": "random",
                "min": 1000000,
                "max": 9999999
            }
        },
        {
            "name": "payload",
            "type": "bytes",
            "max_size": 512
        },
        {
            "name": "checksum",
            "type": "uint32",
            "behavior": {
                "operation": "checksum",
                "algorithm": "crc32",
                "fields": ["sequence", "timestamp", "nonce", "payload"]
            }
        }
    ]
}</pre>
                </div>
                <p>
                    <strong>How it works:</strong> The fuzzer mutates the payload, then automatically updates
                    sequence (increments), timestamp (current time), nonce (random), and checksum (recalculates)
                    before sending. This allows fuzzing while maintaining protocol validity.
                </p>

                <h4>Step 4: Load and Test Your Plugin</h4>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;">Save your plugin file in <code>core/plugins/your_protocol.py</code></li>
                    <li style="margin-bottom: 10px;">Restart the Core: <code>docker-compose restart core</code></li>
                    <li style="margin-bottom: 10px;">Refresh this page and your protocol should appear in the dropdown</li>
                    <li style="margin-bottom: 10px;">Create a session and start fuzzing!</li>
                </ol>

                <h4>Tips for Effective Plugins</h4>
                <ul>
                    <li><strong>Start Simple:</strong> Begin with basic message structure, add complexity later</li>
                    <li><strong>Use Good Seeds:</strong> Provide 3-5 valid message examples in different states</li>
                    <li><strong>Document Everything:</strong> Use comments and docstrings liberally</li>
                    <li><strong>Test Incrementally:</strong> Run short fuzzing sessions after each change</li>
                    <li><strong>Learn from Examples:</strong> Study <code>core/plugins/simple_tcp.py</code></li>
                </ul>

                <h4>Validator Best Practices</h4>
                <p>
                    The validator function is powerful for catching logical bugs:
                </p>
                <ul>
                    <li>Return <code>False</code> for invalid responses (logged as anomalies)</li>
                    <li>Raise <code>ValueError</code> with message for serious logic bugs</li>
                    <li>Check business logic: negative balances, invalid timestamps, wrong sequences</li>
                    <li>Verify protocol invariants: authenticated actions require auth, etc.</li>
                    <li>Keep it fast - this runs on every test case</li>
                </ul>

                <h4>Example: Financial Protocol</h4>
                <div class="code-block">
                    <pre>def validate_response(response: bytes) -> bool:
    """Check financial protocol responses"""
    if len(response) < 10:
        return False

    msg_type = response[8]

    # Check for balance query response
    if msg_type == 0x20:  # BALANCE_RESPONSE
        # Parse balance (big-endian int64 at offset 9)
        balance = int.from_bytes(response[9:17], 'big', signed=True)

        # This should NEVER happen - logic bug!
        if balance < 0:
            raise ValueError(f"Negative balance returned: {balance}")

    return True</pre>
                </div>
            </div>
        </div>

        <!-- Mutation Strategy Guide Tab -->
        <div id="mutation-guide-tab" class="tab-content">
            <div class="help-section">
                <h3>Understanding Mutation Strategies</h3>

                <p>
                    The fuzzer generates test cases using multiple mutation strategies. Each strategy
                    targets different vulnerability classes and code paths.
                </p>

                <h4>1. Bit Flip Mutation</h4>
                <p><strong>Purpose:</strong> Find vulnerabilities in bit-level data handling</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Randomly flips individual bits in the input (0→1, 1→0)</li>
                    <li>Flips ~1% of all bits by default</li>
                    <li>Creates subtle corruption that may bypass validation</li>
                </ul>
                <p><strong>Targets:</strong> Checksum errors, bit flag handling, encoding issues</p>
                <div class="code-block">
                    <pre>Example:
Original: 01001000 01100101 (He)
Mutated:  01001001 01100101 (Ie) ← One bit flipped</pre>
                </div>

                <h4>2. Byte Flip Mutation</h4>
                <p><strong>Purpose:</strong> Test boundary values and character handling</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Replaces ~5% of bytes with random values</li>
                    <li>More aggressive than bit flipping</li>
                    <li>Can create invalid characters or protocol markers</li>
                </ul>
                <p><strong>Targets:</strong> Character encoding bugs, parser errors, magic number validation</p>

                <h4>3. Arithmetic Mutation</h4>
                <p><strong>Purpose:</strong> Trigger integer overflow and underflow vulnerabilities</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Treats 4-byte sequences as integers</li>
                    <li>Adds or subtracts small values: -128, -64, -16, -1, 1, 16, 64, 128</li>
                    <li>Can cause wraparound at MAX_INT boundaries</li>
                </ul>
                <p><strong>Targets:</strong> Buffer size calculations, loop counters, array indices</p>
                <div class="code-block">
                    <pre>Example:
Original length: 1024 (0x00000400)
Mutated length:  1152 (0x00000480) ← Added 128
Effect: May cause buffer overflow if buffer is 1024 bytes</pre>
                </div>

                <h4>4. Interesting Values Mutation</h4>
                <p><strong>Purpose:</strong> Test boundary conditions and edge cases</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Replaces integers with known "interesting" boundary values</li>
                    <li>8-bit: 0, 1, 127, 128, 255</li>
                    <li>16-bit: 0, 1, 255, 256, 32767, 32768, 65535</li>
                    <li>32-bit: 0, 1, 65535, 65536, MAX_INT-1, MAX_INT, MAX_INT+1</li>
                </ul>
                <p><strong>Targets:</strong> Off-by-one errors, signedness bugs, type confusion</p>
                <p><strong>Why these values?</strong></p>
                <ul>
                    <li><code>0</code> - Often causes division by zero or null pointer</li>
                    <li><code>-1 (0xFF...)</code> - Common error return value, max unsigned</li>
                    <li><code>127/128</code> - Signed/unsigned byte boundary</li>
                    <li><code>32767/32768</code> - Signed/unsigned short boundary</li>
                    <li><code>65535/65536</code> - 16-bit max / 17-bit min</li>
                </ul>

                <h4>5. Havoc Mutation</h4>
                <p><strong>Purpose:</strong> Aggressive exploration of input space</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Applies 2-10 random mutations in sequence:
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li><strong>Insert:</strong> Add random bytes at random position</li>
                            <li><strong>Delete:</strong> Remove random bytes</li>
                            <li><strong>Duplicate:</strong> Copy chunk and insert elsewhere</li>
                            <li><strong>Shuffle:</strong> Randomize byte order in a chunk</li>
                        </ul>
                    </li>
                    <li>Can drastically change input structure</li>
                    <li>Good for finding unexpected code paths</li>
                </ul>
                <p><strong>Targets:</strong> Parser robustness, state machine errors, memory corruption</p>

                <h4>6. Splice Mutation</h4>
                <p><strong>Purpose:</strong> Combine features from different seeds</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Takes two different seed inputs</li>
                    <li>Splits each at a random position</li>
                    <li>Combines first half of seed A with second half of seed B</li>
                </ul>
                <p><strong>Targets:</strong> State confusion, context mixing, protocol sequence bugs</p>
                <div class="code-block">
                    <pre>Example:
Seed A: [AUTH_REQUEST][username=alice][password=pass123]
Seed B: [DATA_REQUEST][query=SELECT * FROM users]
Splice: [AUTH_REQUEST][username=alice][query=SELECT * FROM users]
Result: Authentication message with SQL query - may bypass checks!</pre>
                </div>

                <h4>Strategy Selection</h4>
                <p>The fuzzer uses weighted random selection for mutation strategies:</p>
                <ul>
                    <li>Bit Flip: 20%</li>
                    <li>Byte Flip: 20%</li>
                    <li>Arithmetic: 15%</li>
                    <li>Interesting Values: 20%</li>
                    <li>Havoc: 15%</li>
                    <li>Splice: 10%</li>
                </ul>

                <h4>Mutation Pipeline</h4>
                <p>For each test case:</p>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;">Select a seed from the corpus</li>
                    <li style="margin-bottom: 10px;">Choose a mutation strategy (weighted random)</li>
                    <li style="margin-bottom: 10px;">Apply 1-5 mutation passes</li>
                    <li style="margin-bottom: 10px;">Send mutated input to target</li>
                    <li style="margin-bottom: 10px;">Monitor for crashes/anomalies</li>
                    <li style="margin-bottom: 10px;">Repeat</li>
                </ol>

                <h4>Vulnerability Classes Targeted</h4>
                <div class="code-block">
                    <pre><strong>Memory Corruption:</strong>
  • Buffer overflows (arithmetic + havoc)
  • Heap corruption (havoc + splice)
  • Use-after-free (splice + interesting values)

<strong>Integer Issues:</strong>
  • Integer overflow/underflow (arithmetic)
  • Signed/unsigned confusion (interesting values)
  • Type confusion (interesting values + splice)

<strong>Logic Bugs:</strong>
  • State machine errors (splice + havoc)
  • Authentication bypass (splice)
  • Input validation bypass (bit flip + byte flip)

<strong>Parser Errors:</strong>
  • Invalid UTF-8 sequences (byte flip)
  • Malformed structures (havoc)
  • Wrong endianness (bit flip + arithmetic)</pre>
                </div>

                <h4>Advanced: Guided Fuzzing (Phase 2+)</h4>
                <p>Future versions will add:</p>
                <ul>
                    <li><strong>Coverage-Guided:</strong> Prioritize mutations that find new code paths</li>
                    <li><strong>Dictionary-Based:</strong> Insert protocol keywords and constants</li>
                    <li><strong>Structural:</strong> Respect protocol grammar while mutating values</li>
                    <li><strong>Taint-Guided:</strong> Track data flow to mutate effective fields</li>
                </ul>

                <h4>Tips for Effective Fuzzing</h4>
                <ul>
                    <li><strong>Good Seeds Matter:</strong> Provide valid, diverse seed inputs</li>
                    <li><strong>Target Specific Fields:</strong> Use data model to guide mutations</li>
                    <li><strong>Run Long Campaigns:</strong> Many bugs require thousands of iterations</li>
                    <li><strong>Monitor Findings:</strong> Check crash reports regularly</li>
                    <li><strong>Iterate:</strong> Update seeds based on findings</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Help & Documentation</h2>
                <button class="modal-close" onclick="closeHelp()">×</button>
            </div>
            <div>
                <h3 style="color: #0066cc; margin-bottom: 15px;">Quick Links</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><a href="#" onclick="switchTab('help'); closeHelp(); return false;" style="color: #0066cc;">Getting Started Overview</a></li>
                    <li><a href="#" onclick="switchTab('protocol-guide'); closeHelp(); return false;" style="color: #0066cc;">Protocol Authoring Guide</a></li>
                    <li><a href="#" onclick="switchTab('mutation-guide'); closeHelp(); return false;" style="color: #0066cc;">Mutation Strategy Reference</a></li>
                </ul>

                <h3 style="color: #0066cc; margin-top: 30px; margin-bottom: 15px;">External Documentation</h3>
                <ul style="margin-left: 20px; line-height: 2; color: #aaa;">
                    <li><code>QUICKSTART.md</code> - Setup and deployment guide</li>
                    <li><code>CHEATSHEET.md</code> - Quick reference for commands</li>
                    <li><code>blueprint.md</code> - Architecture and design</li>
                    <li><code>roadmap.md</code> - Development phases</li>
                </ul>

                <h3 style="color: #0066cc; margin-top: 30px; margin-bottom: 15px;">Support</h3>
                <p style="color: #aaa; margin-bottom: 10px;">
                    Check Docker logs for debugging:
                </p>
                <div class="code-block">
                    <pre># View all services
docker-compose logs -f

# View specific service
docker-compose logs -f core
docker-compose logs -f target</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        let currentProtocolDetail = null;

        // Checkbox toggle handler
        function toggleCheckbox(element, checkboxId) {
            const checkbox = document.getElementById(checkboxId);
            checkbox.checked = !checkbox.checked;

            if (checkbox.checked) {
                element.classList.add('checked');
            } else {
                element.classList.remove('checked');
            }

            // Prevent event from bubbling to label
            updateConfigurationCoach(currentProtocolDetail);
            event.stopPropagation();
        }

        // Get selected mutators
        function getSelectedMutators() {
            const mutatorIds = [
                'mutator_bitflip',
                'mutator_byteflip',
                'mutator_arithmetic',
                'mutator_interesting',
                'mutator_havoc',
                'mutator_splice'
            ];

            const mutatorMap = {
                'mutator_bitflip': 'bitflip',
                'mutator_byteflip': 'byteflip',
                'mutator_arithmetic': 'arithmetic',
                'mutator_interesting': 'interesting',
                'mutator_havoc': 'havoc',
                'mutator_splice': 'splice'
            };

            const selected = mutatorIds
                .filter(id => document.getElementById(id).checked)
                .map(id => mutatorMap[id]);

            return selected;
        }

        // Update mutation mode UI visibility
        function updateMutationModeUI() {
            const mode = document.querySelector('input[name="mutationMode"]:checked').value;
            const weightControl = document.getElementById('hybridWeightControl');

            // Only show weight slider in hybrid mode
            if (mode === 'hybrid') {
                weightControl.style.display = 'block';
            } else {
                weightControl.style.display = 'none';
            }
        }

        // Get mutation configuration
        function getMutationConfig() {
            const mode = document.querySelector('input[name="mutationMode"]:checked').value;
            const config = {
                mutation_mode: mode
            };

            if (mode === 'hybrid') {
                config.structure_aware_weight = parseInt(document.getElementById('structureAwareWeight').value);
            }

            return config;
        }

        // Tab Management
        function switchTab(tabName, triggerEl) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(btn => btn.classList.remove('active'));

            const targetTab = document.getElementById(`${tabName}-tab`);
            if (targetTab) {
                targetTab.classList.add('active');
            }

            const navButton = triggerEl || document.querySelector(`.nav-tab[data-tab="${tabName}"]`);
            if (navButton) {
                navButton.classList.add('active');
            }
        }

        // Modal Management
        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        // Close modal on background click
        document.getElementById('helpModal').addEventListener('click', (e) => {
            if (e.target.id === 'helpModal') {
                closeHelp();
            }
        });

        // Load protocols on page load
        const protocolCache = {};

        async function fetchProtocolDetail(name) {
            if (!name) return null;
            if (protocolCache[name]) {
                return protocolCache[name];
            }
            const response = await fetch(`${API_BASE}/api/plugins/${name}`);
            if (!response.ok) {
                throw new Error(`Failed to load plugin ${name}`);
            }
            const detail = await response.json();
            protocolCache[name] = detail;
            return detail;
        }

        function describeBehavior(behavior) {
            if (!behavior) return '';
            const op = behavior.operation || behavior.type;
            if (op === 'increment') {
                const step = typeof behavior.step === 'number' ? behavior.step : 1;
                return `increments each send (step ${step})`;
            }
            if (op === 'add_constant') {
                const value = typeof behavior.value === 'number' ? behavior.value : 0;
                return `adds ${value} before sending`;
            }
            return op ? `custom operation: ${op}` : 'custom operation';
        }

        function getDataModel(detail) {
            if (detail && typeof detail === 'object' && detail.data_model) {
                return detail.data_model;
            }
            return {};
        }

        function getStateModel(detail) {
            if (detail && typeof detail === 'object' && detail.state_model) {
                return detail.state_model;
            }
            return {};
        }

        function getBlocks(detail) {
            const model = getDataModel(detail);
            return Array.isArray(model.blocks) ? model.blocks : [];
        }

        function getSeeds(detail) {
            const model = getDataModel(detail);
            return Array.isArray(model.seeds) ? model.seeds : [];
        }

        function isBlockFuzzable(block) {
            if (!block) return false;
            if (block.mutable === false) return false;
            if (block.is_size_field) return false;
            const behavior = block.behavior && typeof block.behavior === 'object' ? block.behavior : null;
            const op = behavior && behavior.operation;
            if (op === 'checksum') return false;
            return true;
        }

        function formatBlockSize(block) {
            if (!block) return 'variable';
            if (block.size) {
                return `${block.size} bytes`;
            }
            if (block.max_size) {
                return `≤ ${block.max_size} bytes`;
            }
            if (block.type && block.type.toLowerCase().startsWith('uint')) {
                return block.type.toUpperCase();
            }
            return 'dynamic';
        }

        function tryBase64Decode(value) {
            try {
                const binary = atob(value);
                const reencoded = btoa(binary);
                if (reencoded.replace(/=+$/, '') === value.replace(/=+$/, '')) {
                    return Array.from(binary, ch => ch.charCodeAt(0));
                }
            } catch (error) {
                return null;
            }
            return null;
        }

        function asByteArray(value) {
            if (!value) return [];
            if (Array.isArray(value)) return value;
            if (typeof value === 'string') {
                const decoded = tryBase64Decode(value);
                if (decoded) {
                    return decoded;
                }
                return Array.from(value, ch => ch.charCodeAt(0));
            }
            if (typeof value === 'number') {
                return [value & 0xff];
            }
            return [];
        }

        function formatHexPreview(bytes, maxBytes = 32) {
            if (!bytes || !bytes.length) return '(empty)';
            const slice = bytes.slice(0, maxBytes);
            const hex = slice.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            return bytes.length > maxBytes ? `${hex} …` : hex;
        }

        function createSyntheticBytes(block, variantSeed = 0, mutated = false) {
            const defaultValue = block ? block.default : undefined;
            const useDefault = !mutated && defaultValue;
            if (useDefault) {
                const defaultBytes = asByteArray(defaultValue);
                if (defaultBytes.length) {
                    return defaultBytes;
                }
            }
            const size = block && typeof block.size === 'number' ? block.size : null;
            const maxSize = block && typeof block.max_size === 'number' ? block.max_size : null;
            const length = size || Math.min(maxSize || 12, 16);
            const name = (block && block.name) || 'block';
            const bytes = [];
            for (let i = 0; i < length; i++) {
                const baseChar = name.charCodeAt((i + variantSeed) % name.length) || 65;
                const noise = mutated ? (variantSeed + 1) * 17 : 7;
                bytes.push((baseChar + noise + i * (mutated ? 23 : 9)) % 256);
            }
            return bytes;
        }

        function formatNumeric(value, bits) {
            if (typeof value !== 'number' || !Number.isFinite(value)) {
                return value && value.toString ? value.toString() : '0x0';
            }
            const width = Math.max(Math.ceil(bits / 4), 2);
            const normalized = value >>> 0;
            return `0x${normalized.toString(16).toUpperCase().padStart(width, '0')}`;
        }

        function computeBlockValue(block, { mutated = false, variantIndex = 0, blocks = null } = {}) {
            if (!block) return 'n/a';
            const type = (block.type || '').toLowerCase();

            // Handle size fields - compute actual size of referenced block
            if (block.is_size_field && block.size_of && blocks) {
                const targetBlock = blocks.find(b => b.name === block.size_of);
                if (targetBlock) {
                    let computedSize = 0;
                    const targetType = (targetBlock.type || '').toLowerCase();

                    if (targetBlock.size) {
                        computedSize = targetBlock.size;
                    } else if (targetType === 'bytes') {
                        const bytes = createSyntheticBytes(targetBlock, variantIndex, mutated);
                        computedSize = bytes.length;
                    } else if (targetType.startsWith('uint') || targetType.startsWith('int')) {
                        const bits = parseInt(targetType.replace(/[a-z]+/, ''), 10) || 8;
                        computedSize = Math.ceil(bits / 8);
                    } else if (targetType === 'string') {
                        const str = typeof targetBlock.default === 'string' ? targetBlock.default : '';
                        computedSize = str.length;
                    }

                    const bits = parseInt(type.replace('uint', ''), 10) || 32;
                    if (!mutated) {
                        return `${formatNumeric(computedSize, bits)} (→${block.size_of})`;
                    } else {
                        // When mutating size fields, show boundary values
                        const interesting = [0, 1, computedSize, Math.pow(2, Math.min(bits, 16)) - 1];
                        const candidate = interesting[variantIndex % interesting.length];
                        return `${formatNumeric(candidate, bits)} (boundary →${block.size_of})`;
                    }
                }
            }

            if (type.startsWith('uint')) {
                const bits = parseInt(type.replace('uint', ''), 10) || 8;
                const values = block.values ? Object.keys(block.values).map(Number).filter(v => !Number.isNaN(v)) : [];
                const defaultValue = typeof block.default === 'number' ? block.default : (values.length ? values[0] : 0);
                if (!mutated) {
                    return formatNumeric(defaultValue, bits);
                }
                const interesting = [1, Math.max(1, Math.pow(2, Math.min(bits, 30)) - 1)];
                const candidate = interesting[variantIndex % interesting.length];
                return `${formatNumeric(candidate, bits)} (boundary)`;
            }
            if (type === 'string') {
                const base = typeof block.default === 'string' ? block.default : (block.name || 'field');
                return mutated ? `${base}_fuzz` : base;
            }
            if (type === 'bytes') {
                const bytes = createSyntheticBytes(block, variantIndex, mutated);
                return formatHexPreview(bytes);
            }
            return mutated ? 'mutated value' : 'default value';
        }

        function mutationNote(block) {
            if (!block) return 'General mutation applied.';
            if (block.values && Object.keys(block.values).length > 1) {
                return 'Switches between documented opcodes to verify alternate handlers.';
            }
            if (block.is_size_field) {
                return 'Pushes reported lengths to stress parser bounds (dependent fields auto-updated).';
            }
            if ((block.type || '').toLowerCase() === 'bytes') {
                return 'Injects high-entropy payload bytes to explore parser states.';
            }
            const behavior = block && block.behavior && typeof block.behavior === 'object' ? block.behavior : null;
            if (behavior && behavior.operation === 'increment') {
                return 'Sequence counters continue to increment while payload fields mutate.';
            }
            return 'Applies boundary values to this numeric field to surface logic bugs.';
        }

        function buildMessagePreview(blocks, focusName, variantIndex) {
            if (!blocks || !blocks.length) {
                return '<span class="empty-state">No blocks defined.</span>';
            }
            return blocks.map(block => {
                const mutated = block.name === focusName;
                const value = computeBlockValue(block, { mutated, variantIndex });
                const cls = mutated ? 'message-segment mutated' : 'message-segment';
                return `<span class="${cls}"><strong>${block.name || 'field'}</strong>: ${value}</span>`;
            }).join('');
        }

        function renderProtocolBlueprint(detail) {
            const diagram = document.getElementById('protocolDiagram');
            const meta = document.getElementById('protocolBlueprintMeta');
            if (!diagram) return;
            if (!detail) {
                diagram.classList.add('empty-state');
                diagram.textContent = 'Select a protocol to visualize its blocks.';
                if (meta) meta.textContent = '';
                return;
            }
            const dataModel = detail && detail.data_model ? detail.data_model : {};
            const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
            const fuzzableCount = blocks.filter(isBlockFuzzable).length;
            if (meta) {
                meta.textContent = blocks.length ? `${blocks.length} block${blocks.length === 1 ? '' : 's'} · ${fuzzableCount} fuzzable` : '';
            }
            if (!blocks.length) {
                diagram.classList.add('empty-state');
                diagram.textContent = 'Protocol has no blocks defined yet.';
                return;
            }
            diagram.classList.remove('empty-state');
            diagram.innerHTML = `
                <div class="protocol-blocks">
                    ${blocks.map(block => {
                        const flags = [];
                        if (isBlockFuzzable(block)) {
                            flags.push('<span class="flag-pill">fuzzable</span>');
                        } else {
                            flags.push('<span class="flag-pill">derived</span>');
                        }
                        if (block.mutable === false) {
                            flags.push('<span class="flag-pill">locked</span>');
                        }
                        if (block.is_size_field) {
                            flags.push('<span class="flag-pill">size field</span>');
                        }
                        if (block.behavior) {
                            flags.push(`<span class="flag-pill behavior">${describeBehavior(block.behavior)}</span>`);
                        }
                        const classes = ['protocol-block', isBlockFuzzable(block) ? 'fuzzable' : 'locked'].join(' ');
                        return `
                            <div class="${classes}">
                                <div class="protocol-block-header">
                                    <span class="block-name">${block.name || 'unnamed'}</span>
                                    <span class="block-type">${(block.type || 'custom').toUpperCase()}</span>
                                </div>
                                <div class="block-meta">
                                    <span>${formatBlockSize(block)}</span>
                                    ${block.size_of ? `<span>controls ${block.size_of}</span>` : ''}
                                </div>
                                ${flags.length ? `<div class="block-flags">${flags.join('')}</div>` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        async function renderTestCaseSamples(detail) {
            const seedContainer = document.getElementById('seedSampleList');
            const mutationContainer = document.getElementById('mutationPreviewList');
            const meta = document.getElementById('sampleCorpusMeta');
            if (!seedContainer || !mutationContainer) return;
            if (!detail) {
                seedContainer.innerHTML = '<p class="empty-state">Provide seeds inside your plugin to preview baseline requests.</p>';
                mutationContainer.innerHTML = '<p class="empty-state">Select a protocol to generate sample mutation plans.</p>';
                if (meta) meta.textContent = '';
                return;
            }

            const protocolName = detail.name;
            const dataModel = detail && detail.data_model ? detail.data_model : {};
            const seeds = Array.isArray(dataModel.seeds) ? dataModel.seeds : [];

            if (meta) {
                meta.textContent = seeds.length ? `${seeds.length} seed${seeds.length === 1 ? '' : 's'} detected` : 'No corpus seeds yet';
            }

            // Render seed previews (still using local logic for simple display)
            if (!seeds.length) {
                seedContainer.innerHTML = '<p class="empty-state">No seeds defined. Add data_model.seeds to preview corpus examples.</p>';
            } else {
                seedContainer.innerHTML = seeds.slice(0, 3).map((seed, idx) => {
                    const bytes = asByteArray(seed);
                    return `
                        <div class="seed-chip">
                            <span>Seed ${idx + 1} · ${bytes.length} bytes</span>
                            <code>${formatHexPreview(bytes)}</code>
                        </div>
                    `;
                }).join('');
                if (seeds.length > 3) {
                    seedContainer.innerHTML += `<div class="field-help">+ ${seeds.length - 3} additional seed${seeds.length - 3 === 1 ? '' : 's'} hidden</div>`;
                }
            }

            // Check if there are fuzzable blocks
            const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
            const fuzzableBlocks = blocks.filter(isBlockFuzzable);
            if (!fuzzableBlocks.length) {
                mutationContainer.innerHTML = '<p class="empty-state">No fuzzable blocks detected. Mark fields as mutable to preview mutation plans.</p>';
                return;
            }

            // Use backend API to generate mutation previews (shows actual fuzzer output)
            try {
                mutationContainer.innerHTML = '<p class="empty-state">Generating mutation previews...</p>';

                const response = await fetch(`${API_BASE}/api/plugins/${protocolName}/preview`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mode: 'mutations',
                        count: 3
                    })
                });

                if (!response.ok) {
                    throw new Error(`Preview generation failed: ${response.statusText}`);
                }

                const data = await response.json();

                mutationContainer.innerHTML = data.previews.map(preview => {
                    const fieldsHtml = preview.fields.map(field => {
                        const computedBadge = field.computed ? `<span class="computed-badge">→${field.references}</span>` : '';
                        const mutatedClass = field.mutated ? 'mutated' : '';
                        const valueDisplay = typeof field.value === 'number' ? `0x${field.value.toString(16).toUpperCase().padStart(2, '0')}` : field.value;
                        return `
                            <div class="field-item ${mutatedClass}">
                                <strong>${field.name}</strong>: ${valueDisplay} ${computedBadge}
                            </div>
                        `;
                    }).join('');

                    return `
                        <div class="sample-case">
                            <div class="sample-case-header">
                                <span>Case ${preview.id + 1} · ${preview.total_bytes} bytes</span>
                                <span>${preview.mode.toUpperCase()}</span>
                            </div>
                            <div class="sample-case-body">
                                <div class="hex-preview">${formatHexPreview(hexStringToBytes(preview.hex_dump), 32)}</div>
                                <div class="field-breakdown">${fieldsHtml}</div>
                            </div>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                mutationContainer.innerHTML = `<p class="empty-state">Failed to generate previews: ${error.message}</p>`;
                console.error('Preview generation error:', error);
            }
        }

        function hexStringToBytes(hexString) {
            const bytes = [];
            for (let i = 0; i < hexString.length; i += 2) {
                bytes.push(parseInt(hexString.substr(i, 2), 16));
            }
            return bytes;
        }

        function updateConfigurationCoach(detail) {
            const container = document.getElementById('configurationCoach');
            if (!container) return;
            const hostInput = document.getElementById('targetHost');
            const portInput = document.getElementById('targetPort');
            const host = hostInput ? hostInput.value.trim() : '';
            const port = portInput ? portInput.value.trim() : '';
            const dataModel = detail && detail.data_model ? detail.data_model : {};
            const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
            const seeds = Array.isArray(dataModel.seeds) ? dataModel.seeds : [];
            const fuzzableBlocks = blocks.filter(isBlockFuzzable);
            const mutators = getSelectedMutators();
            const items = [
                {
                    label: 'Protocol blueprint',
                    status: detail ? 'ready' : 'pending',
                    message: detail ? `${blocks.length} block${blocks.length === 1 ? '' : 's'} detected` : 'Select a protocol plugin to inspect structure.',
                },
                {
                    label: 'Seed corpus',
                    status: seeds.length ? 'ready' : 'warn',
                    message: seeds.length ? `${seeds.length} sample${seeds.length === 1 ? '' : 's'} available` : 'Add data_model.seeds for faster convergence.',
                },
                {
                    label: 'Fuzzable coverage',
                    status: fuzzableBlocks.length ? 'ready' : 'warn',
                    message: fuzzableBlocks.length ? fuzzableBlocks.map(b => b.name).join(', ') : 'All blocks currently locked or derived.',
                },
                {
                    label: 'Mutation plan',
                    status: mutators.length ? 'ready' : 'error',
                    message: mutators.length ? mutators.join(', ') : 'Enable ≥1 mutation strategy.',
                },
                {
                    label: 'Target endpoint',
                    status: host && port ? 'ready' : 'pending',
                    message: host && port ? `${host}:${port}` : 'Provide host & port before launching.',
                },
            ];
            container.innerHTML = items.map(item => `
                <div class="coach-item">
                    <div>
                        <div class="coach-label">${item.label}</div>
                        <div class="coach-message">${item.message}</div>
                    </div>
                    <span class="coach-status ${item.status}">${item.status}</span>
                </div>
            `).join('');

            let tip = 'Ready to fuzz once each row turns green.';
            if (!detail) {
                tip = 'Tip: select a protocol to unlock visualization and previews.';
            } else if (!seeds.length) {
                tip = 'Tip: define at least one seed so the engine can preview baseline requests here.';
            } else if (!fuzzableBlocks.length) {
                tip = 'Tip: mark non-derived blocks as mutable so the fuzzer can touch them.';
            } else if (!host || !port) {
                tip = 'Tip: point the session at a reachable host/port (try make run-target).';
            }
            container.innerHTML += `<div class="coach-tip">${tip}</div>`;
        }

        async function handleProtocolChange(protocolName) {
            if (!protocolName) {
                currentProtocolDetail = null;
                renderProtocolBlueprint(null);
                renderTestCaseSamples(null);
                updateBehaviorSummary(null);
                updateConfigurationCoach(null);
                return;
            }
            try {
                const detail = await fetchProtocolDetail(protocolName);
                currentProtocolDetail = detail;
                updateBehaviorSummary(protocolName, detail);
                renderProtocolBlueprint(detail);
                await renderTestCaseSamples(detail);
                updateConfigurationCoach(detail);
            } catch (error) {
                currentProtocolDetail = null;
                renderProtocolBlueprint(null);
                await renderTestCaseSamples(null);
                updateBehaviorSummary(null);
                updateConfigurationCoach(null);
                showMessage('Failed to load protocol detail: ' + error.message, 'error');
            }
        }

        async function updateBehaviorSummary(protocolName, detailOverride) {
            const summary = document.getElementById('behaviorSummary');
            if (!protocolName) {
                summary.textContent = 'Select a protocol to view automatic field behaviors.';
                return;
            }
            try {
                const detail = detailOverride || await fetchProtocolDetail(protocolName);
                const dataModel = detail && detail.data_model ? detail.data_model : {};
                const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
                const behaviors = blocks.filter(block => block.behavior);
                if (!behaviors.length) {
                    summary.textContent = 'No automatic field behaviors defined in this plugin.';
                    return;
                }
                const items = behaviors
                    .map(block => `<li><strong>${block.name}</strong> — ${describeBehavior(block.behavior)}</li>`)
                    .join('');
                summary.innerHTML = `<span>Automatic operations applied before each message:</span><ul>${items}</ul>`;
            } catch (error) {
                summary.textContent = `Unable to load behavior details: ${error.message}`;
            }
        }

        async function loadProtocols() {
            try {
                const response = await fetch(`${API_BASE}/api/plugins`);
                const protocols = await response.json();
                const sessionSelect = document.getElementById('protocol');
                const debuggerSelect = document.getElementById('pluginDebugProtocol');

                const optionsHtml = protocols.map(p => `<option value="${p}">${p}</option>`).join('');

                if (sessionSelect) {
                    sessionSelect.innerHTML = protocols.length
                        ? optionsHtml
                        : '<option value="">No plugins found</option>';
                }

                if (debuggerSelect) {
                    debuggerSelect.innerHTML = '<option value="">Select a protocol to inspect…</option>' + optionsHtml;
                }

                if (protocols.length && debuggerSelect) {
                    const current = debuggerSelect.value;
                    if (!current || !protocols.includes(current)) {
                        debuggerSelect.value = protocols[0];
                    }
                    await handleProtocolChange(debuggerSelect.value);
                } else {
                    handleProtocolChange(null);
                }
            } catch (error) {
                showMessage('Failed to load protocols: ' + error.message, 'error');
            }
        }

        const pluginDebugSelect = document.getElementById('pluginDebugProtocol');
        if (pluginDebugSelect) {
            pluginDebugSelect.addEventListener('change', (e) => {
                handleProtocolChange(e.target.value);
            });
        }

        // Create session
        document.getElementById('createSessionForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const selectedMutators = getSelectedMutators();

            // Validate at least one mutator is selected
            if (selectedMutators.length === 0) {
                showMessage('⚠️ Please select at least one mutation strategy', 'error');
                return;
            }

            const rateLimit = parseInt(document.getElementById('rateLimit').value);
            const mutationConfig = getMutationConfig();

            const config = {
                protocol: document.getElementById('protocol').value,
                target_host: document.getElementById('targetHost').value,
                target_port: parseInt(document.getElementById('targetPort').value),
                enabled_mutators: selectedMutators,
                ...mutationConfig  // Spread mutation mode config
            };

            // Only include rate_limit_per_second if it's non-zero
            if (rateLimit > 0) {
                config.rate_limit_per_second = rateLimit;
            }

            try {
                const response = await fetch(`${API_BASE}/api/sessions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(config)
                });

                if (response.ok) {
                    const session = await response.json();
                    showMessage(`✓ Session created with ${selectedMutators.length} mutator(s)! Click "Start" to begin fuzzing.`, 'success');
                    loadSessions();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to create session: ' + error.message, 'error');
            }
        });

        ['targetHost', 'targetPort'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('input', () => updateConfigurationCoach(currentProtocolDetail));
            }
        });

        document.querySelectorAll('.checkbox-group input[type="checkbox"]').forEach(input => {
            input.addEventListener('change', () => updateConfigurationCoach(currentProtocolDetail));
        });

        // Load sessions
        async function loadSessions() {
            try {
                const response = await fetch(`${API_BASE}/api/sessions`);
                const sessions = await response.json();

                const container = document.getElementById('sessions');
                if (sessions.length === 0) {
                    container.innerHTML = '<p class="loading">No active sessions. Create one above to get started!</p>';
                } else {
                    container.innerHTML = sessions.map(s => `
                        <div class="session-item">
                            <div class="session-header">
                                <div class="session-info">
                                    <strong>${s.protocol}</strong> → ${s.target_host}:${s.target_port}
                                    <br>
                                    <span class="status-badge status-${s.status}">${s.status}</span>
                                    <small style="color: #888; margin-left: 10px;">
                                        ${s.status === 'running' ? 'Actively fuzzing…' :
                                          s.status === 'idle' ? 'Ready to start' :
                                          s.status === 'completed' ? 'Session completed' :
                                          s.status === 'failed' ? 'Session failed' : ''}
                                    </small>
                                </div>
                                <div class="session-actions">
                                    ${s.status === 'idle' ?
                                        `<button onclick="startSession('${s.id}')" title="Start sending fuzzed inputs to target">Start</button>` :
                                        s.status === 'running' ?
                                        `<button class="danger" onclick="stopSession('${s.id}')" title="Stop fuzzing campaign">Stop</button>` :
                                        s.status === 'failed' ?
                                        `<button class="secondary" onclick="deleteSession('${s.id}')" title="Remove this session">Delete</button>` :
                                        ''
                                    }
                                </div>
                            </div>
                            ${s.error_message ? `
                                <div class="error" style="margin-top: 10px; font-size: 13px;">
                                    <strong>Error:</strong> ${s.error_message}
                                </div>
                            ` : ''}
                            ${s.enabled_mutators && s.enabled_mutators.length > 0 ? `
                                <div style="margin-top: 10px; font-size: 12px; color: #888;">
                                    <strong>Mutators:</strong> ${s.enabled_mutators.join(', ')}
                                    ${s.rate_limit_per_second && s.rate_limit_per_second > 0 ?
                                        ` | <strong>Rate:</strong> ${s.rate_limit_per_second} tests/sec` :
                                        ' | <strong>Rate:</strong> Unlimited'}
                                </div>
                            ` : ''}
                            ${s.mutation_mode ? `
                                <div style="margin-top: 5px; font-size: 12px; color: #4a9eff;">
                                    <strong>Mutation:</strong> ${s.mutation_mode === 'hybrid' ? 'Hybrid' : s.mutation_mode === 'structure_aware' ? 'Structure-Aware' : 'Byte-Level'}
                                    ${s.mutation_mode === 'hybrid' && s.structure_aware_weight ? ` (${s.structure_aware_weight}% structure-aware)` : ''}
                                </div>
                            ` : ''}
                            <div class="session-details">
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Total Tests</div>
                                    <div class="session-detail-value">${s.total_tests.toLocaleString()}</div>
                                    <span class="tooltiptext">
                                        Number of mutated inputs sent to target in this session.
                                        Each test applies mutation strategies (bit flip, arithmetic, etc.)
                                        to seed corpus. More tests = more thorough fuzzing.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Crashes</div>
                                    <div class="session-detail-value" style="color: ${s.crashes > 0 ? '#cc0000' : '#fff'}">${s.crashes}</div>
                                    <span class="tooltiptext">
                                        Program crashes detected. Includes connection failures,
                                        segmentation faults, and abnormal terminations. Each crash
                                        is a potential security vulnerability. Saved in data/crashes/.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Hangs</div>
                                    <div class="session-detail-value" style="color: ${s.hangs > 0 ? '#ff9900' : '#fff'}">${s.hangs}</div>
                                    <span class="tooltiptext">
                                        Timeout events where target stopped responding. May indicate
                                        infinite loops, deadlocks, or resource exhaustion. Timeout
                                        threshold: 5 seconds (configurable). Can lead to DoS.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Anomalies</div>
                                    <div class="session-detail-value" style="color: ${s.anomalies > 0 ? '#ffcc00' : '#fff'}">${s.anomalies}</div>
                                    <span class="tooltiptext">
                                        Logical failures detected by validator oracles. Target
                                        didn't crash but returned invalid/unexpected responses.
                                        Examples: negative balance, wrong state, invalid format.
                                        Check validator in protocol plugin.
                                    </span>
                                </div>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (error) {
                document.getElementById('sessions').innerHTML =
                    `<p class="error">Failed to load sessions: ${error.message}</p>`;
            }
        }

        // Start session
        async function startSession(sessionId) {
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${sessionId}/start`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showMessage('✓ Fuzzing started! Monitor the statistics below.', 'success');
                    loadSessions();
                    startStatsPolling();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to start session: ' + error.message, 'error');
            }
        }

        // Stop session
        async function stopSession(sessionId) {
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${sessionId}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showMessage('✓ Fuzzing session stopped. Check findings in data/crashes/.', 'info');
                    loadSessions();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to stop session: ' + error.message, 'error');
            }
        }

        // Delete session
        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                return;
            }

            // For now, just hide it from UI (full implementation would call DELETE endpoint)
            showMessage('Session removed from view. Refresh page to see all sessions.', 'info');
            loadSessions();
        }

        // Update system stats
        async function updateStats() {
            try {
                const [health, corpus, sessions] = await Promise.all([
                    fetch(`${API_BASE}/api/system/health`).then(r => r.json()),
                    fetch(`${API_BASE}/api/corpus/stats`).then(r => r.json()),
                    fetch(`${API_BASE}/api/sessions`).then(r => r.json())
                ]);

                document.getElementById('activeSessions').textContent = health.active_sessions;
                document.getElementById('totalSeeds').textContent = corpus.total_seeds;
                document.getElementById('totalFindings').textContent = corpus.total_findings;

                const totalTests = sessions.reduce((sum, s) => sum + s.total_tests, 0);
                document.getElementById('totalTests').textContent = totalTests.toLocaleString();
            } catch (error) {
                console.error('Failed to update stats:', error);
            }
        }

        // Show message
        function showMessage(text, type) {
            const div = document.createElement('div');
            div.className = type;
            div.textContent = text;
            document.getElementById('messages').appendChild(div);
            setTimeout(() => div.remove(), 8000);
        }

        // Polling
        let statsInterval;
        function startStatsPolling() {
            if (statsInterval) return;
            statsInterval = setInterval(() => {
                updateStats();
                loadSessions();
            }, 2000);
        }

        // Expose selected helpers globally for inline handlers
        window.switchTab = switchTab;
        window.showHelp = showHelp;
        window.closeHelp = closeHelp;
        window.toggleCheckbox = toggleCheckbox;
        window.startSession = startSession;
        window.stopSession = stopSession;
        window.deleteSession = deleteSession;

        // Initialize
        loadProtocols();
        loadSessions();
        updateStats();
        startStatsPolling();
        updateConfigurationCoach(null);

        // Show welcome message on first load
        if (!sessionStorage.getItem('welcomed')) {
            setTimeout(() => {
                showMessage('Welcome! Check the "Getting Started" tab for a tutorial, or create a session above to begin fuzzing.', 'info');
                sessionStorage.setItem('welcomed', 'true');
            }, 1000);
        }
    </script>
</body>
</html>
