<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proprietary Protocol Fuzzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
        }

        .help-btn {
            background: #444;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .help-btn:hover {
            background: #555;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
        }

        .nav-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .nav-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: #252525;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }

        .card h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #fff;
        }

        .insight-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .insight-grid {
                grid-template-columns: 1fr;
            }
        }

        .insight-panel {
            background: #1b1b1b;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .insight-panel.state-machine-panel-full {
            margin-top: 20px;
        }

        .protocol-selector-row {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .protocol-selector-row select {
            flex: 1;
        }

        .reload-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .reload-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(16, 185, 129, 0.3);
        }

        .reload-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        .reload-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .reload-icon {
            font-size: 18px;
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .reload-btn.loading .reload-icon {
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .insight-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .insight-panel-header h3 {
            font-size: 16px;
            color: #fff;
        }

        .insight-meta {
            font-size: 12px;
            color: #777;
        }

        .protocol-diagram {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .protocol-blocks {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .protocol-block {
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px;
            background: #161616;
        }

        .protocol-block.fuzzable {
            border-color: #0f8ecb;
            box-shadow: inset 0 0 0 1px rgba(15, 142, 203, 0.2);
        }

        .protocol-block.locked {
            opacity: 0.8;
        }

        .protocol-block-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .block-name {
            font-weight: 600;
            color: #f5f5f5;
        }

        .block-type {
            font-size: 12px;
            color: #9ac7ff;
            background: rgba(0, 102, 204, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .block-meta {
            font-size: 12px;
            color: #aaa;
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .block-flags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .flag-pill {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 999px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #bbb;
        }

        .flag-pill.behavior {
            border-color: #0066cc;
            color: #66b0ff;
        }

        .protocol-legend {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #888;
        }

        .protocol-legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .legend-dot.fuzzable {
            background: #0f8ecb;
        }

        .legend-dot.locked {
            background: #555;
        }

        .seed-preview {
            display: flex;
            flex-direction: column;
            gap: 10px;
            font-size: 12px;
        }

        .seed-chip {
            border: 1px dashed #333;
            padding: 8px;
            border-radius: 6px;
            background: #111;
        }

        .seed-chip span {
            font-size: 12px;
            color: #aaa;
            display: block;
            margin-bottom: 4px;
        }

        .seed-chip code {
            display: block;
            color: #fff;
            font-size: 11px;
            white-space: nowrap;
            overflow-x: auto;
        }

        .mutation-previews {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .sample-case {
            border: 1px solid #333;
            border-radius: 6px;
            padding: 10px;
            background: #121212;
        }

        .sample-case-header {
            display: flex;
            justify-content: space-between;
            font-size: 13px;
            margin-bottom: 6px;
            color: #ddd;
        }

        .sample-case-body {
            font-size: 12px;
            color: #bbb;
            line-height: 1.5;
        }

        .message-preview {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 11px;
        }

        .message-segment {
            background: #1e1e1e;
            border-radius: 4px;
            padding: 4px 6px;
            border: 1px solid #2e2e2e;
        }

        .message-segment.mutated {
            border-color: #0f8ecb;
            color: #66b0ff;
        }

        .computed-badge {
            font-size: 10px;
            color: #4a9eff;
            margin-left: 4px;
            opacity: 0.8;
        }

        .field-breakdown {
            margin-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .field-item {
            padding: 4px 8px;
            background: #1a1a1a;
            border-radius: 3px;
            font-size: 11px;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .field-item.mutated {
            background: #1a2530;
            border-left: 2px solid #0f8ecb;
        }

        .hex-preview {
            padding: 8px;
            background: #0a0a0a;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 11px;
            color: #888;
            overflow-x: auto;
            white-space: nowrap;
        }

        .badge-group {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
        }

        .type-badge {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .type-badge-structure {
            background: #1a3a2a;
            color: #4ade80;
            border: 1px solid #22543d;
        }

        .type-badge-byte {
            background: #3a1a1a;
            color: #fca5a5;
            border: 1px solid #7f1d1d;
        }

        .mutator-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            font-weight: 500;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .mutator-badge-structure {
            background: #1e3a26;
            color: #86efac;
            border: 1px solid #2d5a3d;
        }

        .mutator-badge-byte {
            background: #3a1e1e;
            color: #f59e9e;
            border: 1px solid #5a2d2d;
        }

        .mutation-description {
            margin-bottom: 8px;
            padding: 8px;
            background: #1a1a1a;
            border-left: 3px solid #0f8ecb;
            border-radius: 3px;
            font-size: 11px;
            color: #999;
            line-height: 1.4;
        }

        /* State Machine Diagram */
        .state-machine-panel-body {
            min-height: 140px;
        }

        .state-machine-panel-body.empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .state-machine-diagram {
            margin-bottom: 0;
            padding: 15px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 1px solid #2a4365;
            border-radius: 8px;
        }

        .state-machine-note {
            margin: 0 0 15px 0;
            font-size: 11px;
            color: #94a3b8;
            line-height: 1.4;
        }

        .state-flow {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            padding: 10px 0;
        }

        @media (max-width: 1200px) {
            .state-flow {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .state-flow {
                grid-template-columns: 1fr;
            }
        }

        .state-box {
            padding: 16px;
            background: #0f172a;
            border: 2px solid #334155;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .state-box:hover {
            border-color: #475569;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .state-box.state-initial {
            border-color: #10b981;
            background: linear-gradient(135deg, #064e3b 0%, #0f172a 100%);
        }

        .state-name {
            font-size: 13px;
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .initial-badge {
            font-size: 9px;
            padding: 2px 6px;
            background: #10b981;
            color: #fff;
            border-radius: 3px;
            font-weight: 600;
        }

        .state-transitions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .state-transition-item {
            font-size: 10px;
            padding: 6px;
            background: #1e293b;
            border-left: 2px solid #3b82f6;
            border-radius: 3px;
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .transition-message {
            color: #60a5fa;
            font-weight: 600;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .transition-arrow-simple {
            color: #64748b;
            margin: 0 4px;
        }

        .transition-target {
            color: #10b981;
            font-weight: 600;
        }

        .transition-response {
            font-size: 9px;
            color: #94a3b8;
            font-style: italic;
        }

        .state-terminal {
            font-size: 10px;
            color: #64748b;
            font-style: italic;
            padding: 6px;
            text-align: center;
        }

        /* State Transition Info in Preview Cards */
        .state-transition-info {
            margin-bottom: 8px;
            padding: 8px;
            background: #0f172a;
            border-left: 3px solid #8b5cf6;
            border-radius: 3px;
            font-size: 10px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
        }

        .state-label {
            color: #94a3b8;
            font-weight: 500;
        }

        .message-type-badge {
            padding: 2px 8px;
            background: #5b21b6;
            color: #e9d5ff;
            border-radius: 3px;
            font-weight: 600;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .state-badge {
            padding: 2px 8px;
            background: #065f46;
            color: #6ee7b7;
            border-radius: 3px;
            font-weight: 600;
        }

        .transition-arrow {
            color: #60a5fa;
            font-weight: 600;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .sample-case-structure_aware {
            border-left: 3px solid #4ade80;
        }

        .sample-case-byte_level {
            border-left: 3px solid #fca5a5;
        }

        .coach-panel {
            margin-top: 20px;
        }

        .coach-checklist {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .coach-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #333;
            background: #111;
            font-size: 13px;
        }

        .coach-label {
            font-weight: 600;
            color: #eee;
        }

        .coach-message {
            font-size: 12px;
            color: #aaa;
        }

        .coach-status {
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 700;
        }

        .coach-status.ready {
            background: rgba(0, 170, 0, 0.2);
            color: #6fff80;
        }

        .coach-status.warn {
            background: rgba(255, 204, 0, 0.15);
            color: #ffdd66;
        }

        .coach-status.error {
            background: rgba(204, 0, 0, 0.2);
            color: #ff8f8f;
        }

        .coach-status.pending {
            background: rgba(153, 153, 153, 0.2);
            color: #ccc;
        }

        .coach-tip {
            font-size: 12px;
            color: #9ac7ff;
            border-top: 1px dashed #333;
            padding-top: 10px;
        }

        .empty-state {
            color: #666;
            font-size: 13px;
        }

        .guide-links {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .guide-links a {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: #1f1f1f;
            border: 1px solid #333;
            border-radius: 6px;
            color: #66b0ff;
            text-decoration: none;
            font-size: 14px;
        }

        .guide-links a:hover {
            background: #252525;
            border-color: #0066cc;
        }

        .behavior-summary {
            margin-top: 15px;
            padding: 12px;
            background: #1f1f1f;
            border: 1px dashed #333;
            border-radius: 6px;
            font-size: 13px;
            color: #cbcaca;
        }

        .behavior-summary ul {
            margin-top: 8px;
            margin-left: 18px;
        }

        .behavior-summary li {
            margin-bottom: 4px;
        }

        .card-description {
            color: #888;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-left: 3px solid #0066cc;
            border-radius: 4px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .help-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: #444;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            cursor: help;
            color: #aaa;
        }

        .help-icon:hover {
            background: #0066cc;
            color: white;
        }

        .field-help {
            font-size: 12px;
            color: #666;
            margin-top: 3px;
            font-style: italic;
        }

        input, select {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #0066cc;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        button:hover {
            background: #0052a3;
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
        }

        button.secondary {
            background: #444;
        }

        button.secondary:hover {
            background: #555;
        }

        button.danger {
            background: #cc0000;
        }

        button.danger:hover {
            background: #990000;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-idle { background: #444; }
        .status-running { background: #00aa00; animation: pulse 2s infinite; }
        .status-completed { background: #0066cc; }
        .status-failed { background: #cc0000; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .session-item {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .session-info {
            flex-grow: 1;
        }

        .session-actions {
            display: flex;
            gap: 10px;
        }

        .session-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }

        .session-detail {
            font-size: 12px;
        }

        .session-detail-label {
            color: #666;
        }

        .session-detail-value {
            color: #fff;
            font-weight: 600;
        }

        .error {
            background: #cc0000;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .success {
            background: #00aa00;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .info {
            background: #0066cc;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .help-section {
            background: #252525;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .help-section h3 {
            color: #0066cc;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .help-section h4 {
            color: #fff;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .help-section p {
            color: #aaa;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .help-section ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .help-section li {
            color: #aaa;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .code-block {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #0066cc;
            margin: 15px 0;
            overflow-x: auto;
        }

        .code-block pre {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .highlight {
            background: #0066cc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: #252525;
            border-radius: 8px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }

        .modal-title {
            font-size: 24px;
            color: #fff;
        }

        .modal-close {
            background: #444;
            border: none;
            color: #fff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        .modal-close:hover {
            background: #cc0000;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .step-indicator {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #0066cc;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            color: white;
            font-weight: bold;
            margin-right: 10px;
        }

        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-item:hover {
            background: #252525;
            border-color: #0066cc;
        }

        .checkbox-item input[type="checkbox"] {
            width: auto;
            margin: 0;
            cursor: pointer;
        }

        .checkbox-item label {
            margin: 0;
            cursor: pointer;
            flex-grow: 1;
            color: #e0e0e0;
            font-size: 13px;
        }

        .checkbox-item.checked {
            background: #1a3a5a;
            border-color: #0066cc;
        }

        .mutator-description {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
            display: block;
        }

        .mutation-guide {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mutation-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 13px;
        }

        .mutation-table th,
        .mutation-table td {
            text-align: left;
            padding: 10px;
            border-bottom: 1px solid #333;
            vertical-align: top;
        }

        .mutation-table th {
            background: #1f1f1f;
            border-top: 1px solid #333;
            color: #ddd;
            font-weight: 600;
        }

        .mutation-table td strong {
            color: #fff;
        }

        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
            gap: 16px;
            margin-top: 15px;
        }

        .strategy-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 10px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 220px;
        }

        .strategy-card.structure {
            border-color: #22c55e;
        }

        .strategy-card.byte {
            border-color: #f97316;
        }

        .strategy-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            padding: 4px 10px;
            border-radius: 999px;
            font-weight: 600;
        }

        .strategy-badge.structure {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .strategy-badge.byte {
            background: rgba(249, 115, 22, 0.15);
            color: #fca5a5;
            border: 1px solid rgba(249, 115, 22, 0.3);
        }

        .strategy-card h3 {
            font-size: 16px;
            margin: 0;
        }

        .strategy-card ul {
            margin-left: 18px;
            color: #b3b3b3;
        }

        .strategy-card ul li {
            margin-bottom: 6px;
        }

        .strategy-meta {
            font-size: 12px;
            color: #999;
            margin-top: auto;
        }

        .strategy-meta span {
            display: inline-block;
            margin-right: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1>Proprietary Protocol Fuzzer</h1>
                <p class="subtitle">Portable & Extensible Network Protocol Security Testing Framework</p>
            </div>
            <button class="help-btn" onclick="showHelp()">Help & Guides</button>
        </header>

        <div id="messages"></div>

        <!-- Navigation Tabs -->
        <div class="nav-tabs">
            <button class="nav-tab active" data-tab="dashboard" onclick="switchTab('dashboard', this)">Dashboard</button>
            <button class="nav-tab" data-tab="plugin-debug" onclick="switchTab('plugin-debug', this)">Plugin Debugger</button>
            <button class="nav-tab" data-tab="oneoff-test" onclick="switchTab('oneoff-test', this)">One-Off Test</button>
            <button class="nav-tab" data-tab="correlation" onclick="switchTab('correlation', this)">Test Case Correlation</button>
            <button class="nav-tab" data-tab="help" onclick="switchTab('help', this)">Getting Started</button>
            <button class="nav-tab" data-tab="protocol-guide" onclick="switchTab('protocol-guide', this)">Protocol Guide</button>
            <button class="nav-tab" data-tab="mutation-guide" onclick="switchTab('mutation-guide', this)">Mutation Guide</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard-tab" class="tab-content active">
            <div class="grid">
                <!-- Create Session -->
                <div class="card">
                    <h2>Create Fuzzing Session</h2>
                    <div class="card-description">
                        <strong>Step 1:</strong> Configure your fuzzing campaign. Select a protocol plugin,
                        specify the target host and port, then create a session. The fuzzer will use the
                        protocol's seed corpus and mutation strategies to generate test cases.
                    </div>
                    <form id="createSessionForm">
                        <div class="form-group">
                            <label for="protocol">
                                Protocol Plugin
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Protocol plugins define the message structure (data model) and
                                        state machine for your target protocol. Custom plugins can be
                                        added to the core/plugins/ directory.
                                    </span>
                                </span>
                            </label>
                            <select id="protocol" required>
                                <option value="">Loading protocols...</option>
                            </select>
                            <div class="field-help">Choose a protocol that matches your target application</div>
                        </div>
                        <div class="form-group">
                            <label for="targetHost">
                                Target Host
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Hostname or IP address of the target server.
                                        <br><br>
                                        <strong>Docker networking:</strong><br>
                                        • Use 'target' for SimpleTCP test server<br>
                                        • Use '172.17.0.1' (Linux) to reach host from container<br>
                                        • Use 'host.docker.internal' (Mac/Windows) to reach host<br>
                                        • 'localhost' only works if Core is NOT in Docker
                                    </span>
                                </span>
                            </label>
                            <input type="text" id="targetHost" value="target" required>
                            <div class="field-help">
                                <strong>Docker:</strong> Use 'target' for test server, or '172.17.0.1' to reach host.
                                <strong>Local:</strong> Use 'localhost' or IP address.
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="targetPort">
                                Target Port
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        TCP port number where your target service is listening.
                                        Common ports: 80 (HTTP), 443 (HTTPS), 9999 (SimpleTCP test server).
                                    </span>
                                </span>
                            </label>
                            <input type="number" id="targetPort" value="9999" required min="1" max="65535">
                            <div class="field-help">Port number between 1-65535</div>
                        </div>
                        <div class="form-group">
                            <label for="rateLimit">
                                Rate Limit (tests/second)
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Maximum number of test cases to execute per second.
                                        Lower values give the target more time to process each input
                                        and make it easier to manually observe behavior.
                                        Set to 0 for unlimited (maximum throughput).
                                        Recommended: 10-100 for manual observation, 0 for maximum speed.
                                    </span>
                                </span>
                            </label>
                            <input type="number" id="rateLimit" value="0" min="0" max="10000" step="1">
                            <div class="field-help">0 = unlimited, 1-10000 = tests per second. Lower values help prevent dropped connections.</div>
                        </div>
                        <div class="form-group">
                            <label>
                                Mutation Mode
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Controls how test cases are mutated:
                                        • Structure-Aware: Respects protocol grammar, auto-fixes lengths/checksums (~90% valid messages)
                                        • Byte-Level: Traditional bit/byte flips, finds parser bugs (~5% valid messages)
                                        • Hybrid: Mix of both (recommended) - gets deep code coverage + parser bugs
                                    </span>
                                </span>
                            </label>
                            <div style="margin-top: 10px;">
                                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="radio" name="mutationMode" value="hybrid" checked onchange="updateMutationModeUI()">
                                        <span>Hybrid (Recommended)</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="radio" name="mutationMode" value="structure_aware" onchange="updateMutationModeUI()">
                                        <span>Structure-Aware Only</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px; cursor: pointer;">
                                        <input type="radio" name="mutationMode" value="byte_level" onchange="updateMutationModeUI()">
                                        <span>Byte-Level Only</span>
                                    </label>
                                </div>
                            </div>
                            <div id="hybridWeightControl" style="margin-top: 15px; padding: 10px; background: #1a1a1a; border: 1px solid #444; border-radius: 4px;">
                                <label for="structureAwareWeight" style="display: block; margin-bottom: 8px;">
                                    Structure-Aware Weight: <span id="weightValue">70</span>%
                                    <span class="tooltip">
                                        <span class="help-icon">?</span>
                                        <span class="tooltiptext">
                                            Percentage of mutations that use structure-aware approach.
                                            Higher = more valid messages and deeper code coverage.
                                            Lower = more parser testing and edge case discovery.
                                        </span>
                                    </span>
                                </label>
                                <input type="range" id="structureAwareWeight" min="0" max="100" value="70"
                                       oninput="document.getElementById('weightValue').textContent = this.value"
                                       style="width: 100%; cursor: pointer;">
                                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888; margin-top: 5px;">
                                    <span>0% (All Byte-Level)</span>
                                    <span>50% (Balanced)</span>
                                    <span>100% (All Structure-Aware)</span>
                                </div>
                            </div>
                            <div class="field-help">Structure-aware mutations respect protocol grammar and auto-fix dependent fields</div>
                        </div>
                        <div class="form-group">
                            <label>
                                Mutation Strategies
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Select which mutation strategies to enable for this session.
                                        Each strategy targets different vulnerability classes.
                                        See the "Mutation Guide" tab for detailed descriptions.
                                        All strategies are enabled by default.
                                    </span>
                                </span>
                            </label>
                            <div class="checkbox-group">
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_bitflip')">
                                    <input type="checkbox" id="mutator_bitflip" checked>
                                    <label for="mutator_bitflip">
                                        Bit Flip
                                        <span class="mutator-description">Flips individual bits (0→1, 1→0)</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_byteflip')">
                                    <input type="checkbox" id="mutator_byteflip" checked>
                                    <label for="mutator_byteflip">
                                        Byte Flip
                                        <span class="mutator-description">Replaces bytes with random values</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_arithmetic')">
                                    <input type="checkbox" id="mutator_arithmetic" checked>
                                    <label for="mutator_arithmetic">
                                        Arithmetic
                                        <span class="mutator-description">Integer overflow/underflow tests</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_interesting')">
                                    <input type="checkbox" id="mutator_interesting" checked>
                                    <label for="mutator_interesting">
                                        Interesting Values
                                        <span class="mutator-description">Boundary values (0, MAX_INT, etc.)</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_havoc')">
                                    <input type="checkbox" id="mutator_havoc" checked>
                                    <label for="mutator_havoc">
                                        Havoc
                                        <span class="mutator-description">Aggressive insert/delete/shuffle</span>
                                    </label>
                                </div>
                                <div class="checkbox-item checked" onclick="toggleCheckbox(this, 'mutator_splice')">
                                    <input type="checkbox" id="mutator_splice" checked>
                                    <label for="mutator_splice">
                                        Splice
                                        <span class="mutator-description">Combines different seed inputs</span>
                                    </label>
                                </div>
                            </div>
                            <div class="field-help">At least one mutator must be selected</div>
                        </div>
                        <button type="submit">Create Session</button>
                    </form>
                    <div class="field-help">
                        Need protocol blueprints, corpus previews, or readiness tips? Switch to the
                        <strong>Plugin Debugger</strong> tab to pick a protocol for deep inspection without
                        altering the session form.
                    </div>
                </div>

                <!-- System Status -->
                <div class="card">
                    <h2>System Status</h2>
                    <div class="card-description">
                        <strong>Live Metrics:</strong> Real-time overview of fuzzing activity.
                        Active sessions show running fuzzing campaigns. Seeds are test inputs from
                        protocol plugins. Findings are potential vulnerabilities detected by the oracles.
                    </div>
                    <div class="stats">
                        <div class="stat tooltip">
                            <div class="stat-value" id="activeSessions">0</div>
                            <div class="stat-label">Active Sessions</div>
                            <span class="tooltiptext">
                                Number of fuzzing sessions currently running. Each session targets
                                a specific protocol/host combination and continuously generates
                                test cases. Multiple sessions can run concurrently.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalSeeds">0</div>
                            <div class="stat-label">Corpus Seeds</div>
                            <span class="tooltiptext">
                                Number of seed inputs in the corpus. Seeds are valid protocol messages
                                used as starting points for mutation. More diverse seeds = better
                                code coverage. Seeds come from protocol plugins or manual uploads.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalFindings">0</div>
                            <div class="stat-label">Findings</div>
                            <span class="tooltiptext">
                                Number of potential vulnerabilities discovered. Findings include
                                crashes, hangs, and logical failures. Each finding is saved with
                                full reproduction data in data/crashes/ directory. Findings are
                                persisted across restarts.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalTests">0</div>
                            <div class="stat-label">Total Tests</div>
                            <span class="tooltiptext">
                                Cumulative test cases executed across all sessions. Each test sends
                                one mutated input to the target. Higher numbers indicate more
                                thorough fuzzing. Typical rate: 100-1000 tests/sec depending on
                                target response time.
                            </span>
                        </div>
                    </div>
                </div>

            </div>

            <!-- Active Sessions -->
            <div class="card">
                <h2>Fuzzing Sessions</h2>
                <div class="card-description">
                    <strong>Session Management:</strong> Monitor and control your fuzzing campaigns. Each session
                    represents an independent fuzzing run targeting a specific protocol/host combination.
                    Click <strong>Start</strong> to begin sending mutated test cases to the target. The fuzzer
                    will continuously generate inputs using various mutation strategies and report any crashes,
                    hangs, or anomalies detected by the intelligent oracles.
                </div>
                <div id="sessions" class="loading">Loading sessions...</div>
            </div>
        </div>

        <!-- Plugin Debugger Tab -->
        <div id="plugin-debug-tab" class="tab-content">
            <div class="card">
                <h2>Protocol Plugin Debugger</h2>
                <div class="card-description">
                    Purpose-built diagnostics for protocol authors. Inspect protocol blueprints, seed
                    corpora, mutation previews, and readiness checks without cluttering the primary
                    session dashboard. Use the selector below to pick which plugin to visualize—the
                    session form stays untouched.
                </div>
                <div class="form-group">
                    <label for="pluginDebugProtocol">
                        Protocol Plugin (Debugger)
                        <span class="tooltip">
                            <span class="help-icon">?</span>
                            <span class="tooltiptext">
                                Choose which plugin to visualize. This selection only affects the
                                debugger panels—session creation remains independent.
                            </span>
                        </span>
                    </label>
                    <div class="protocol-selector-row">
                        <select id="pluginDebugProtocol">
                            <option value="">Select a protocol to inspect…</option>
                        </select>
                        <button id="reloadPluginBtn" class="reload-btn" title="Reload current protocol plugin">
                            <span class="reload-icon">⟳</span> Reload
                        </button>
                    </div>
                    <div class="field-help">Debugger data updates when you pick a protocol here.</div>
                </div>
                <div id="behaviorSummary" class="behavior-summary">
                    Select a protocol to view automatic field behaviors.
                </div>
                <div class="insight-grid">
                    <div class="insight-panel">
                        <div class="insight-panel-header">
                            <h3>Protocol Blueprint</h3>
                            <span id="protocolBlueprintMeta" class="insight-meta"></span>
                        </div>
                        <div class="protocol-legend">
                            <span><span class="legend-dot fuzzable"></span>Fuzzable</span>
                            <span><span class="legend-dot locked"></span>Locked/derived</span>
                        </div>
                        <div id="protocolDiagram" class="protocol-diagram empty-state">
                            Select a protocol to visualize its blocks.
                        </div>
                    </div>
                    <div class="insight-panel">
                        <div class="insight-panel-header">
                            <h3>Test Case Explorer</h3>
                            <span id="sampleCorpusMeta" class="insight-meta"></span>
                        </div>
                        <div class="seed-preview" id="seedSampleList">
                            Provide seeds inside your plugin to preview baseline requests.
                        </div>
                        <div class="mutation-previews" id="mutationPreviewList">
                            Select a protocol to generate sample mutation plans.
                        </div>
                    </div>
                </div>
                <div class="insight-panel state-machine-panel-full">
                    <div class="insight-panel-header">
                        <h3>Protocol State Machine</h3>
                        <span id="stateMachineMeta" class="insight-meta"></span>
                    </div>
                    <div id="stateMachinePanel" class="state-machine-panel-body empty-state">
                        Select a protocol to visualize its state model.
                    </div>
                </div>
                <div class="insight-panel coach-panel">
                    <div class="insight-panel-header">
                        <h3>Configuration Coach</h3>
                    </div>
                    <div id="configurationCoach" class="coach-checklist">
                        Fill in your target details to receive readiness feedback.
                    </div>
                </div>
            </div>
        </div>

        <!-- One-Off Test Tab -->
        <div id="oneoff-test-tab" class="tab-content">
            <div class="card">
                <h2>One-Off Test Execution</h2>
                <div class="card-description">
                    Send a single test message to your target without creating a full fuzzing session.
                    Perfect for quick validation, reproduction of specific payloads, or manual testing
                    of edge cases. Use this to verify connectivity, test custom payloads, or confirm
                    crash reproducibility.
                </div>

                <form id="oneOffTestForm" onsubmit="executeOneOffTest(event)">
                    <div class="form-group">
                        <label for="oneoffProtocol">
                            Protocol Plugin
                            <span class="tooltip">
                                <span class="help-icon">?</span>
                                <span class="tooltiptext">
                                    Select the protocol plugin that matches your target's message format.
                                    This helps with payload construction and validation.
                                </span>
                            </span>
                        </label>
                        <select id="oneoffProtocol" required>
                            <option value="">Loading protocols...</option>
                        </select>
                        <div class="field-help">Choose the protocol for message encoding</div>
                    </div>

                    <div class="form-group">
                        <label for="oneoffTargetHost">
                            Target Host
                            <span class="tooltip">
                                <span class="help-icon">?</span>
                                <span class="tooltiptext">
                                    Hostname or IP address of the target server.
                                    <br><br>
                                    <strong>Docker networking:</strong><br>
                                    • Use 'target' for SimpleTCP test server<br>
                                    • Use '172.17.0.1' (Linux) to reach host from container<br>
                                    • Use 'host.docker.internal' (Mac/Windows) to reach host
                                </span>
                            </span>
                        </label>
                        <input type="text" id="oneoffTargetHost" value="target" required>
                        <div class="field-help">Hostname or IP address</div>
                    </div>

                    <div class="form-group">
                        <label for="oneoffTargetPort">
                            Target Port
                            <span class="tooltip">
                                <span class="help-icon">?</span>
                                <span class="tooltiptext">
                                    TCP port number where your target service is listening.
                                </span>
                            </span>
                        </label>
                        <input type="number" id="oneoffTargetPort" value="9999" required min="1" max="65535">
                        <div class="field-help">Port number (1-65535)</div>
                    </div>

                    <div class="form-group">
                        <label for="oneoffPayloadFormat">
                            Payload Format
                            <span class="tooltip">
                                <span class="help-icon">?</span>
                                <span class="tooltiptext">
                                    Choose how you want to input your test payload:
                                    <br>• Hex: Space-separated hex bytes (e.g., "53 54 43 50 01")
                                    <br>• Base64: Base64-encoded binary data
                                    <br>• Text: Raw text string (will be UTF-8 encoded)
                                </span>
                            </span>
                        </label>
                        <select id="oneoffPayloadFormat" onchange="updatePayloadPlaceholder()">
                            <option value="hex">Hex (space-separated)</option>
                            <option value="base64">Base64</option>
                            <option value="text">Text (UTF-8)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="oneoffPayload">
                            Payload
                            <span class="tooltip">
                                <span class="help-icon">?</span>
                                <span class="tooltiptext">
                                    Enter your test payload in the selected format.
                                    For SimpleTCP, a valid AUTH message in hex is:
                                    "53 54 43 50 00 00 00 05 01 48 45 4c 4c 4f"
                                </span>
                            </span>
                        </label>
                        <textarea id="oneoffPayload" rows="5" required placeholder="53 54 43 50 00 00 00 05 01 48 45 4c 4c 4f"></textarea>
                        <div class="field-help" id="oneoffPayloadHelp">
                            Enter hex bytes (space-separated). Example SimpleTCP AUTH: "53 54 43 50 00 00 00 05 01 48 45 4c 4c 4f"
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="oneoffTimeout">
                            Timeout (ms)
                            <span class="tooltip">
                                <span class="help-icon">?</span>
                                <span class="tooltiptext">
                                    Maximum time to wait for a response before considering the test timed out.
                                    Increase for slow targets or networks.
                                </span>
                            </span>
                        </label>
                        <input type="number" id="oneoffTimeout" value="5000" min="100" max="60000" step="100">
                        <div class="field-help">100-60000 ms (default: 5000)</div>
                    </div>

                    <button type="submit" class="button" id="oneoffSubmitBtn">
                        🚀 Send Test Message
                    </button>
                </form>

                <div id="oneoffResults" style="margin-top: 30px; display: none;">
                    <h3 style="margin-bottom: 15px; color: #fff;">Test Results</h3>

                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                        <div class="stat-card">
                            <div class="stat-label">Result</div>
                            <div class="stat-value" id="oneoffResultStatus">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Execution Time</div>
                            <div class="stat-value" id="oneoffResultTime">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Response Size</div>
                            <div class="stat-value" id="oneoffResultSize">-</div>
                        </div>
                    </div>

                    <div id="oneoffResponseSection" style="margin-top: 20px; display: none;">
                        <h4 style="margin-bottom: 10px; color: #fff;">Response Data</h4>
                        <div style="background: #2a2a2a; padding: 15px; border-radius: 4px; margin-bottom: 10px;">
                            <div style="color: #888; font-size: 0.9em; margin-bottom: 5px;">Hex:</div>
                            <pre id="oneoffResponseHex" style="font-family: monospace; font-size: 0.9em; word-break: break-all; white-space: pre-wrap; margin: 0;"></pre>
                        </div>
                        <div style="background: #2a2a2a; padding: 15px; border-radius: 4px;">
                            <div style="color: #888; font-size: 0.9em; margin-bottom: 5px;">ASCII:</div>
                            <pre id="oneoffResponseAscii" style="font-family: monospace; font-size: 0.9em; word-break: break-all; white-space: pre-wrap; margin: 0;"></pre>
                        </div>
                    </div>

                    <div id="oneoffErrorSection" style="margin-top: 20px; padding: 15px; background: #3a1a1a; border: 1px solid #d32f2f; border-radius: 4px; display: none;">
                        <h4 style="margin-bottom: 10px; color: #ff5252;">Error Details</h4>
                        <pre id="oneoffErrorText" style="font-family: monospace; font-size: 0.9em; word-break: break-all; white-space: pre-wrap; margin: 0; color: #ffcdd2;"></pre>
                    </div>

                    <div id="oneoffCrashSection" style="margin-top: 20px; padding: 15px; background: #2a1a1a; border: 1px solid #ff9800; border-radius: 4px; display: none;">
                        <h4 style="margin-bottom: 10px; color: #ffb74d;">🔥 Crash Detected</h4>
                        <p style="margin-bottom: 10px;">This test case triggered a crash! Finding saved to corpus.</p>
                        <div style="color: #888;">
                            <strong>Crash Report ID:</strong> <span id="oneoffCrashId" style="font-family: monospace; color: #ffb74d;">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card" style="margin-top: 20px;">
                <h3>Quick Reference</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                    <div>
                        <h4 style="color: #888; font-size: 0.9em; margin-bottom: 10px;">SimpleTCP Test Messages</h4>
                        <div style="font-family: monospace; font-size: 0.85em; line-height: 1.6;">
                            <div style="margin-bottom: 8px;">
                                <strong style="color: #4caf50;">AUTH:</strong><br>
                                <span style="color: #888;">53 54 43 50 00 00 00 05 01 48 45 4c 4c 4f</span>
                            </div>
                            <div style="margin-bottom: 8px;">
                                <strong style="color: #2196f3;">DATA:</strong><br>
                                <span style="color: #888;">53 54 43 50 00 00 00 04 02 54 45 53 54</span>
                            </div>
                            <div>
                                <strong style="color: #f44336;">QUIT:</strong><br>
                                <span style="color: #888;">53 54 43 50 00 00 00 00 03</span>
                            </div>
                        </div>
                    </div>
                    <div>
                        <h4 style="color: #888; font-size: 0.9em; margin-bottom: 10px;">Use Cases</h4>
                        <ul style="font-size: 0.9em; line-height: 1.6; padding-left: 20px;">
                            <li>Quick connectivity validation</li>
                            <li>Reproduce crash-inducing payloads</li>
                            <li>Test specific edge cases manually</li>
                            <li>Verify target response format</li>
                            <li>Debug protocol parsing logic</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Test Case Correlation Tab -->
        <div id="correlation-tab" class="tab-content">
            <div class="card-description" style="margin-bottom: 20px;">
                <strong>Purpose:</strong> When you observe an issue on the target (crash, hang, anomaly),
                use this tool to identify which test case caused it, then replay to confirm reproducibility.
            </div>

            <!-- Session Selector -->
            <div class="card" style="margin-bottom: 20px;">
                <h2>Select Session</h2>
                <div class="form-group">
                    <label for="correlationSessionSelect">Active or Recent Session</label>
                    <select id="correlationSessionSelect" onchange="loadCorrelationSession()">
                        <option value="">-- Select a session --</option>
                    </select>
                    <div class="field-help">Choose a session to view its execution history</div>
                </div>
                <div id="correlationSessionInfo" style="margin-top: 15px; display: none;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                        <div>
                            <strong>Protocol:</strong> <span id="corrSessionProtocol">-</span>
                        </div>
                        <div>
                            <strong>Target:</strong> <span id="corrSessionTarget">-</span>
                        </div>
                        <div>
                            <strong>Status:</strong> <span id="corrSessionStatus">-</span>
                        </div>
                        <div>
                            <strong>Total Tests:</strong> <span id="corrSessionTotal">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="grid" style="grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <!-- Time-based Search -->
                <div class="card">
                    <h2>🕒 Find by Timestamp</h2>
                    <div class="card-description">
                        Find which test case was executing at a specific time.
                        <strong>Use case:</strong> "Target crashed at 10:23:45, what was running?"
                    </div>
                    <div class="form-group">
                        <label for="searchTimestamp">Timestamp (ISO 8601)</label>
                        <input type="datetime-local" id="searchTimestamp" step="1">
                        <div class="field-help">
                            Select date and time when the issue occurred
                        </div>
                    </div>
                    <button onclick="findByTimestamp()" class="button">Find Test Case</button>
                    <button onclick="setCurrentTime()" class="button" style="margin-left: 10px; background: #555;">Use Current Time</button>
                </div>

                <!-- Sequence-based Search -->
                <div class="card">
                    <h2>🔢 Find by Sequence Number</h2>
                    <div class="card-description">
                        Retrieve a specific test case by its sequence number.
                        <strong>Use case:</strong> "Show me test case #847"
                    </div>
                    <div class="form-group">
                        <label for="searchSequence">Sequence Number</label>
                        <input type="number" id="searchSequence" min="1" placeholder="e.g., 847">
                        <div class="field-help">
                            Enter the test case number from the timeline
                        </div>
                    </div>
                    <button onclick="findBySequence()" class="button">Get Test Case</button>
                </div>
            </div>

            <!-- Time Band Replay -->
            <div class="card" style="margin-bottom: 20px;">
                <h2>⏯️ Time Band Replay</h2>
                <div class="card-description">
                    <strong>Use case:</strong> "I saw a crash around 10:23:45, replay 10:23:40-10:23:50 slowly to identify the exact test case"
                </div>
                <div class="grid" style="grid-template-columns: 1fr 1fr 200px; gap: 15px; align-items: end;">
                    <div class="form-group">
                        <label for="replayStartTime">Start Time</label>
                        <input type="datetime-local" id="replayStartTime" step="1">
                    </div>
                    <div class="form-group">
                        <label for="replayEndTime">End Time</label>
                        <input type="datetime-local" id="replayEndTime" step="1">
                    </div>
                    <div class="form-group">
                        <label for="replayDelay">Delay (ms)</label>
                        <input type="number" id="replayDelay" value="500" min="0" max="10000" step="100">
                    </div>
                </div>
                <button onclick="replayTimeRange()" class="button" style="margin-top: 10px;">
                    ▶️ Replay Time Range
                </button>
                <div id="replayProgress" style="margin-top: 10px; display: none;">
                    <div class="progress-bar" style="background: #333; height: 20px; border-radius: 4px; overflow: hidden;">
                        <div id="replayProgressBar" style="background: #4caf50; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 5px; color: #888;">
                        <span id="replayProgressText">Replaying...</span>
                    </div>
                </div>
            </div>

            <!-- Timeline View -->
            <div class="card">
                <h2>📋 Execution Timeline</h2>
                <div class="card-description">
                    Recent test case executions (auto-updates every 2s when session is running)
                </div>
                <div style="margin-bottom: 15px;">
                    <label>
                        <input type="checkbox" id="autoRefreshTimeline" checked>
                        Auto-refresh (2s interval)
                    </label>
                    <button onclick="refreshTimeline()" class="button" style="margin-left: 15px; padding: 5px 15px;">
                        ⟳ Refresh Now
                    </button>
                    <span style="margin-left: 15px; color: #888;">
                        Showing last <span id="timelineCount">0</span> executions
                    </span>
                </div>
                <div style="overflow-x: auto;">
                    <table id="timelineTable" style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #2a2a2a; text-align: left;">
                                <th style="padding: 10px; border-bottom: 2px solid #444;">#</th>
                                <th style="padding: 10px; border-bottom: 2px solid #444;">Time Sent</th>
                                <th style="padding: 10px; border-bottom: 2px solid #444;">Message Type</th>
                                <th style="padding: 10px; border-bottom: 2px solid #444;">State</th>
                                <th style="padding: 10px; border-bottom: 2px solid #444;">Result</th>
                                <th style="padding: 10px; border-bottom: 2px solid #444;">Duration (ms)</th>
                                <th style="padding: 10px; border-bottom: 2px solid #444;">Payload Size</th>
                                <th style="padding: 10px; border-bottom: 2px solid #444;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="timelineBody">
                            <tr>
                                <td colspan="8" style="padding: 20px; text-align: center; color: #888;">
                                    Select a session to view execution history
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Detail View Modal -->
            <div id="executionDetailModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 1000; overflow-y: auto; padding: 40px;">
                <div style="max-width: 900px; margin: 0 auto; background: #1e1e1e; border-radius: 8px; padding: 30px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h2 style="margin: 0;">Test Case Details</h2>
                        <button onclick="closeDetailModal()" style="background: #555; border: none; color: white; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 16px;">✕ Close</button>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <strong>Sequence Number:</strong> #<span id="detailSequence">-</span>
                        </div>
                        <div>
                            <strong>Test Case ID:</strong> <span id="detailId" style="font-family: monospace; font-size: 0.9em;">-</span>
                        </div>
                        <div>
                            <strong>Time Sent:</strong> <span id="detailTimeSent">-</span>
                        </div>
                        <div>
                            <strong>Time Response:</strong> <span id="detailTimeResponse">-</span>
                        </div>
                        <div>
                            <strong>Duration:</strong> <span id="detailDuration">-</span> ms
                        </div>
                        <div>
                            <strong>Result:</strong> <span id="detailResult" class="badge">-</span>
                        </div>
                        <div>
                            <strong>Protocol:</strong> <span id="detailProtocol">-</span>
                        </div>
                        <div>
                            <strong>Message Type:</strong> <span id="detailMessageType">-</span>
                        </div>
                        <div>
                            <strong>State at Send:</strong> <span id="detailState">-</span>
                        </div>
                        <div>
                            <strong>Payload Hash:</strong> <span id="detailHash" style="font-family: monospace; font-size: 0.85em; word-break: break-all;">-</span>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">Payload Preview (first 64 bytes)</h3>
                        <div id="detailPayloadPreview" style="background: #2a2a2a; padding: 15px; border-radius: 4px; font-family: monospace; word-break: break-all; font-size: 0.9em;">
                            -
                        </div>
                        <div style="margin-top: 5px; color: #888; font-size: 0.9em;">
                            Total size: <span id="detailPayloadSize">-</span> bytes
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;" id="detailResponseSection">
                        <h3 style="margin-bottom: 10px;">Response Preview (first 64 bytes)</h3>
                        <div id="detailResponsePreview" style="background: #2a2a2a; padding: 15px; border-radius: 4px; font-family: monospace; word-break: break-all; font-size: 0.9em;">
                            -
                        </div>
                        <div style="margin-top: 5px; color: #888; font-size: 0.9em;">
                            Total size: <span id="detailResponseSize">-</span> bytes
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h3 style="margin-bottom: 10px;">Full Payload (Base64)</h3>
                        <textarea id="detailFullPayload" readonly style="width: 100%; height: 120px; background: #2a2a2a; border: 1px solid #444; color: #ddd; padding: 10px; font-family: monospace; font-size: 0.85em; resize: vertical;"></textarea>
                        <button onclick="copyFullPayload()" class="button" style="margin-top: 10px;">
                            📋 Copy to Clipboard
                        </button>
                    </div>

                    <div style="padding: 15px; background: #2a2a2a; border-radius: 4px; text-align: center;">
                        <button onclick="replaySingleTestCase()" class="button" style="font-size: 16px; padding: 12px 30px;">
                            ▶️ Replay This Test Case
                        </button>
                        <div style="margin-top: 10px; color: #888; font-size: 0.9em;">
                            Re-sends this exact payload to the target to confirm reproducibility
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Help Tab -->
        <div id="help-tab" class="tab-content">
            <div class="help-section">
                <h3>Getting Started with Protocol Fuzzing</h3>

                <h4><span class="step-indicator">1</span>Understanding the Dashboard</h4>
                <p>
                    The dashboard is your control center for fuzzing campaigns. Here's what each section does:
                </p>
                <ul>
                    <li><strong>Create Fuzzing Session:</strong> Configure a new fuzzing campaign by selecting a protocol, target host, and port.</li>
                    <li><strong>System Status:</strong> Real-time metrics showing active sessions, corpus size, findings, and total tests executed.</li>
                    <li><strong>Fuzzing Sessions:</strong> Manage running campaigns - start, stop, and monitor progress.</li>
                </ul>

                <h4><span class="step-indicator">2</span>Creating Your First Session</h4>
                <p>To start fuzzing:</p>
                <ul>
                    <li>Select a <strong>Protocol</strong> from the dropdown (e.g., "simple_tcp" for testing)</li>
                    <li>Enter the <strong>Target Host</strong> - use "target" for the Docker test server, or "localhost" for local testing</li>
                    <li>Specify the <strong>Target Port</strong> - the default SimpleTCP test server uses port 9999</li>
                    <li>Click <strong>"Create Session"</strong> to initialize the fuzzing campaign</li>
                    <li>Once created, click <strong>"Start"</strong> to begin fuzzing</li>
                </ul>

                <h4><span class="step-indicator">3</span>Monitoring Results</h4>
                <p>
                    As the fuzzer runs, watch for these key metrics:
                </p>
                <ul>
                    <li><strong>Tests:</strong> Number of mutated inputs sent to the target</li>
                    <li><strong>Crashes:</strong> Detected program crashes or connection failures</li>
                    <li><strong>Hangs:</strong> Timeouts indicating the target stopped responding</li>
                    <li><strong>Anomalies:</strong> Unexpected behavior detected by the validator oracles</li>
                </ul>

                <h4><span class="step-indicator">4</span>Understanding the Fuzzing Process</h4>
                <p>
                    The fuzzer operates in several stages:
                </p>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;"><strong>Seed Selection:</strong> The fuzzer starts with seed inputs from the protocol plugin</li>
                    <li style="margin-bottom: 10px;"><strong>Mutation:</strong> Multiple mutation strategies (bit flips, byte replacements, boundary values) create variations</li>
                    <li style="margin-bottom: 10px;"><strong>Execution:</strong> Mutated inputs are sent to the target via TCP connections</li>
                    <li style="margin-bottom: 10px;"><strong>Monitoring:</strong> Intelligent oracles watch for crashes, hangs, and logical failures</li>
                    <li style="margin-bottom: 10px;"><strong>Reporting:</strong> Findings are saved with full reproducers for analysis</li>
                </ol>

                <h4><span class="step-indicator">5</span>Testing with the SimpleTCP Server</h4>
                <p>
                    The included SimpleTCP test server has intentional vulnerabilities for demonstration:
                </p>
                <div class="code-block">
                    <pre># View target logs to see fuzzing in action
docker-compose logs -f target

# You'll see:
[+] Connection from (172.20.0.3, ...)
[-] Invalid magic: b'\x7f\xffCP'  ← Mutated headers
[+] Command: 0x91, Length: 4      ← Fuzzed commands</pre>
                </div>

                <h4><span class="step-indicator">6</span>Data Types & Size Planning</h4>
                <p>
                    Plugins support a variety of field encodings. Match the data type to the on-the-wire
                    representation to keep the mutator output valid:
                </p>
                <ul>
                    <li><strong>uint8/uint16/uint32/uint64:</strong> 1-, 2-, 4-, or 8-byte unsigned integers. Specify <code>endian</code> for values wider than 1 byte.</li>
                    <li><strong>int16/int32:</strong> Signed integer forms for targets that expect negative offsets or lengths.</li>
                    <li><strong>bytes:</strong> Raw byte buffers; pair with <code>size</code> for fixed headers or <code>max_size</code> for fuzzable blobs.</li>
                    <li><strong>ascii</strong> / <strong>utf8</strong> strings:</strong> Useful for command verbs or keywords; set <code>max_size</code> to bound mutations.</li>
                    <li><strong>bits</strong> or flag fields:</strong> Model tightly packed control bits using <code>type: "bits"</code> with a <code>bit_length</code> to keep masks aligned.</li>
                </ul>
                <p>
                    Size tips: align multi-byte fields on natural boundaries (2, 4, 8) to match target structs, mark checksum or length holders with
                    <code>is_size_field</code> / <code>size_of</code>, and cap variable payloads with realistic <code>max_size</code> limits so the engine stays performant.
                </p>

                <h4><span class="step-indicator">7</span>Endianness Refresher</h4>
                <p>
                    Network software often mixes big- and little-endian integers. In plugins, set <code>endian: "big"</code> for network byte order (most significant byte first)
                    or <code>endian: "little"</code> for little-endian targets such as many Windows services. Fields without an explicit setting default to little-endian.
                    When a message embeds both styles, declare them per block so the blueprint, behaviors, and mutators keep each field consistent.
                </p>

                <h4><span class="step-indicator">8</span>Next Steps</h4>
                <ul>
                    <li>Check the <strong>"Protocol Guide"</strong> tab to learn how to create custom protocol plugins</li>
                    <li>Read the <strong>"Mutation Guide"</strong> tab to understand test case generation strategies</li>
                    <li>View <code>QUICKSTART.md</code> for Docker deployment and local testing instructions</li>
                    <li>Examine findings in the <code>data/crashes/</code> directory</li>
                </ul>
            </div>
        </div>

        <!-- Protocol Creation Guide Tab -->
        <div id="protocol-guide-tab" class="tab-content">
            <div class="help-section">
                <h3>Creating Custom Protocol Plugins</h3>

                <p>
                    Protocol plugins are simple Python files that define your target protocol's structure and behavior.
                    The fuzzer uses this information to generate intelligent test cases.
                </p>

                <h4>Plugin Architecture</h4>
                <p>Each plugin consists of three main components:</p>
                <ul>
                    <li><strong>Data Model:</strong> Defines message structure (headers, fields, data types)</li>
                    <li><strong>State Model:</strong> Defines protocol state machine and transitions</li>
                    <li><strong>Validator (Optional):</strong> Custom logic to detect logical failures</li>
                </ul>

                <h4>Step 1: Create the Plugin File</h4>
                <p>Create a new file in <code>core/plugins/your_protocol.py</code>:</p>

                <div class="code-block">
                    <pre>"""
My Custom Protocol Plugin
Implements fuzzing for MyProtocol v1.0
"""

__version__ = "1.0.0"

# Required: Data Model
data_model = {
    "name": "MyProtocol",
    "description": "Custom protocol for MyApp",

    # Define message structure as blocks
    "blocks": [
        {
            "name": "magic",           # Field identifier
            "type": "bytes",           # Data type
            "size": 4,                 # Fixed size in bytes
            "default": b"MYPK",        # Default value
            "mutable": False           # Don't mutate (for magic headers)
        },
        {
            "name": "length",
            "type": "uint32",          # 32-bit unsigned integer
            "endian": "big",           # big or little endian
            "is_size_field": True,     # This field indicates data size
            "size_of": "payload"       # References another field
        },
        {
            "name": "command",
            "type": "uint8",           # 8-bit unsigned integer
            "values": {                # Known command codes
                0x01: "CONNECT",
                0x02: "DATA",
                0x03: "DISCONNECT"
            }
        },
        {
            "name": "payload",
            "type": "bytes",
            "max_size": 1024,          # Maximum size for mutation
            "default": b""
        }
    ],

    # Seed corpus: example messages for fuzzing
    "seeds": [
        b"MYPK\x00\x00\x00\x05\x01HELLO",
        b"MYPK\x00\x00\x00\x04\x02DATA",
        b"MYPK\x00\x00\x00\x00\x03"
    ]
}

# Required: State Model
state_model = {
    "initial_state": "INIT",

    # Define protocol states
    "states": ["INIT", "CONNECTED", "AUTHENTICATED", "CLOSED"],

    # Define state transitions
    "transitions": [
        {
            "from": "INIT",
            "to": "CONNECTED",
            "trigger": "connect",
            "message_type": "CONNECT",
            "expected_response": "CONNECT_OK"
        },
        {
            "from": "CONNECTED",
            "to": "AUTHENTICATED",
            "trigger": "authenticate",
            "message_type": "AUTH",
            "expected_response": "AUTH_OK"
        },
        {
            "from": "AUTHENTICATED",
            "to": "AUTHENTICATED",
            "trigger": "data_exchange",
            "message_type": "DATA"
        },
        {
            "from": "AUTHENTICATED",
            "to": "CLOSED",
            "trigger": "disconnect",
            "message_type": "DISCONNECT"
        }
    ]
}

# Optional: Custom Response Validator
def validate_response(response: bytes) -> bool:
    """
    Application-specific response validation.

    This is your "Specification Oracle" - check for logical
    errors that wouldn't cause a crash but violate protocol rules.

    Args:
        response: Raw response bytes from target

    Returns:
        True if response is valid, False if logical error detected

    Raises:
        ValueError: To flag as logical failure with description
    """
    if len(response) < 4:
        return False

    # Verify magic header
    if response[:4] != b"MYPK":
        return False

    # Example: Check for application-specific errors
    if len(response) > 8:
        command = response[8]

        # Error response should never happen in normal flow
        if command == 0xFF:
            return False

        # Check for impossible states
        # Example: Balance should never be negative in financial protocol
        # if response_type == "BALANCE" and parse_balance(response) < 0:
        #     raise ValueError("Negative balance detected - logic bug!")

    return True</pre>
                </div>

                <h4>Step 2: Field Types Reference</h4>
                <p>Available field types for the data model:</p>
                <ul>
                    <li><code>bytes</code> - Raw byte array (requires <code>size</code> or <code>max_size</code>)</li>
                    <li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> - Unsigned integers</li>
                    <li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> - Signed integers</li>
                    <li><code>string</code> - UTF-8 text (specify <code>encoding</code>)</li>
                </ul>

                <h4>Step 3: Advanced Features</h4>
                <p>Mark fields for special handling:</p>
                <ul>
                    <li><code>mutable: False</code> - Prevent fuzzer from mutating this field (use for magic headers)</li>
                    <li><code>is_size_field: True</code> - This field specifies another field's length</li>
                    <li><code>size_of: "fieldname"</code> - Link size field to data field</li>
                    <li><code>values: {}</code> - Dictionary of known/valid values for documentation</li>
                </ul>

                <h4>Field Behavior Operations (Auto-Update Fields)</h4>
                <p>
                    You can define automatic operations that are applied to fields before each message is sent.
                    This is useful for sequence numbers, timestamps, checksums, and other dynamic fields.
                </p>
                <p><strong>Available Operations:</strong></p>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">1. Increment Operation</h4>
                <p style="margin-left: 20px;">
                    Automatically increments the field value by a fixed step on each send. Perfect for sequence numbers, packet IDs, or counters.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "sequence_number",
    "type": "uint32",
    "behavior": {
        "operation": "increment",
        "step": 1,              // How much to add (default: 1)
        "start": 0              // Starting value (optional)
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>step</code>: Amount to increment each time (default: 1)</li>
                    <li><code>start</code>: Initial value (optional, uses field default if not specified)</li>
                    <li><strong>Example:</strong> Message 1: seq=0, Message 2: seq=1, Message 3: seq=2, ...</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">2. Add Constant Operation</h4>
                <p style="margin-left: 20px;">
                    Adds a constant value to the field before sending. Useful for applying offsets or adjustments.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "adjusted_value",
    "type": "uint16",
    "behavior": {
        "operation": "add_constant",
        "value": 100            // Value to add before sending
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>value</code>: Constant to add to field value before each send</li>
                    <li><strong>Example:</strong> If field contains 50, sends 150 (50 + 100)</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">3. Timestamp Operation</h4>
                <p style="margin-left: 20px;">
                    Automatically sets the field to current Unix timestamp. Essential for time-sensitive protocols.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "timestamp",
    "type": "uint64",
    "behavior": {
        "operation": "timestamp",
        "format": "unix_seconds"   // or "unix_milliseconds"
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>format</code>: "unix_seconds" or "unix_milliseconds"</li>
                    <li><strong>Example:</strong> Each message gets current time: 1699123456</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">4. Random Operation</h4>
                <p style="margin-left: 20px;">
                    Generates a random value within specified range. Useful for nonces, random IDs, or varying test data.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "nonce",
    "type": "uint32",
    "behavior": {
        "operation": "random",
        "min": 0,               // Minimum value (default: 0)
        "max": 4294967295       // Maximum value (default: type max)
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>min</code>: Minimum random value (inclusive)</li>
                    <li><code>max</code>: Maximum random value (inclusive)</li>
                    <li><strong>Example:</strong> Each message gets random value: 1847562, 9234512, ...</li>
                </ul>

                <h4 style="font-size: 15px; margin-top: 15px; margin-left: 20px;">5. Checksum/CRC Operation</h4>
                <p style="margin-left: 20px;">
                    Calculates checksum over specified message fields. Keeps integrity checks valid even with mutations.
                </p>
                <div class="code-block">
                    <pre>{
    "name": "checksum",
    "type": "uint32",
    "behavior": {
        "operation": "checksum",
        "algorithm": "crc32",      // crc32, crc16, md5, sha256, etc.
        "fields": ["payload"],     // Fields to include in calculation
        "offset": 0                // Where to start calculation (optional)
    }
}</pre>
                </div>
                <ul style="margin-left: 20px;">
                    <li><code>algorithm</code>: crc32, crc16, adler32, md5, sha256, etc.</li>
                    <li><code>fields</code>: Array of field names to include in checksum</li>
                    <li><code>offset</code>: Byte offset where calculation starts (optional)</li>
                </ul>

                <h4 style="margin-top: 15px;">Complete Example with Behaviors</h4>
                <div class="code-block">
                    <pre>data_model = {
    "name": "AdvancedProtocol",
    "blocks": [
        {
            "name": "magic",
            "type": "bytes",
            "size": 4,
            "default": b"ADVP",
            "mutable": False
        },
        {
            "name": "sequence",
            "type": "uint32",
            "behavior": {
                "operation": "increment",
                "step": 1
            }
        },
        {
            "name": "timestamp",
            "type": "uint64",
            "behavior": {
                "operation": "timestamp",
                "format": "unix_seconds"
            }
        },
        {
            "name": "nonce",
            "type": "uint32",
            "behavior": {
                "operation": "random",
                "min": 1000000,
                "max": 9999999
            }
        },
        {
            "name": "payload",
            "type": "bytes",
            "max_size": 512
        },
        {
            "name": "checksum",
            "type": "uint32",
            "behavior": {
                "operation": "checksum",
                "algorithm": "crc32",
                "fields": ["sequence", "timestamp", "nonce", "payload"]
            }
        }
    ]
}</pre>
                </div>
                <p>
                    <strong>How it works:</strong> The fuzzer mutates the payload, then automatically updates
                    sequence (increments), timestamp (current time), nonce (random), and checksum (recalculates)
                    before sending. This allows fuzzing while maintaining protocol validity.
                </p>

                <h4>Step 4: Load and Test Your Plugin</h4>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;">Save your plugin file in <code>core/plugins/your_protocol.py</code></li>
                    <li style="margin-bottom: 10px;">Restart the Core: <code>docker-compose restart core</code></li>
                    <li style="margin-bottom: 10px;">Refresh this page and your protocol should appear in the dropdown</li>
                    <li style="margin-bottom: 10px;">Create a session and start fuzzing!</li>
                </ol>

                <h4>Tips for Effective Plugins</h4>
                <ul>
                    <li><strong>Start Simple:</strong> Begin with basic message structure, add complexity later</li>
                    <li><strong>Use Good Seeds:</strong> Provide 3-5 valid message examples in different states</li>
                    <li><strong>Document Everything:</strong> Use comments and docstrings liberally</li>
                    <li><strong>Test Incrementally:</strong> Run short fuzzing sessions after each change</li>
                    <li><strong>Learn from Examples:</strong> Study <code>core/plugins/simple_tcp.py</code></li>
                </ul>

                <h4>Validator Best Practices</h4>
                <p>
                    The validator function is powerful for catching logical bugs:
                </p>
                <ul>
                    <li>Return <code>False</code> for invalid responses (logged as anomalies)</li>
                    <li>Raise <code>ValueError</code> with message for serious logic bugs</li>
                    <li>Check business logic: negative balances, invalid timestamps, wrong sequences</li>
                    <li>Verify protocol invariants: authenticated actions require auth, etc.</li>
                    <li>Keep it fast - this runs on every test case</li>
                </ul>

                <h4>Example: Financial Protocol</h4>
                <div class="code-block">
                    <pre>def validate_response(response: bytes) -> bool:
    """Check financial protocol responses"""
    if len(response) < 10:
        return False

    msg_type = response[8]

    # Check for balance query response
    if msg_type == 0x20:  # BALANCE_RESPONSE
        # Parse balance (big-endian int64 at offset 9)
        balance = int.from_bytes(response[9:17], 'big', signed=True)

        # This should NEVER happen - logic bug!
        if balance < 0:
            raise ValueError(f"Negative balance returned: {balance}")

    return True</pre>
                </div>
            </div>
        </div>

        <!-- Mutation Strategy Guide Tab -->
        <div id="mutation-guide-tab" class="tab-content">
            <div class="mutation-guide">
                <div class="card">
                    <h2>Mutation Strategy Overview</h2>
                    <p>
                        Every preview in the Test Case Explorer now calls out its mutation type, mutators used,
                        and a short explanation. Use the quick reference below to map those badges to the
                        fuzzing behavior you are observing.
                    </p>

                    <table class="mutation-table">
                        <thead>
                            <tr>
                                <th>Strategy</th>
                                <th>Type</th>
                                <th>What it does</th>
                                <th>When to watch for it</th>
                                <th>UI cues</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Structure-Aware</strong></td>
                                <td>Protocol-aware</td>
                                <td>Rebuilds packets through the data model while tweaking one field at a time.</td>
                                <td>Verifying grammar coverage, declarative behaviors, and field constraints.</td>
                                <td>Green <code>Structure-Aware</code> badge + mutated field label when detected.</td>
                            </tr>
                            <tr>
                                <td><strong>Bit Flip</strong></td>
                                <td>Byte-level</td>
                                <td>Flips individual bits (~1% of payload) to create subtle corruption.</td>
                                <td>Flag toggles, checksums, parity bits, fragile encodings.</td>
                                <td>Red <code>Byte-Level</code> badge + <code>bitflip</code> pill.</td>
                            </tr>
                            <tr>
                                <td><strong>Byte Flip</strong></td>
                                <td>Byte-level</td>
                                <td>Replaces random bytes entirely, ignoring field boundaries.</td>
                                <td>Magic values, opcodes, ASCII/token parsing, coarse corruption.</td>
                                <td>Red badge + <code>byteflip</code> pill.</td>
                            </tr>
                            <tr>
                                <td><strong>Arithmetic</strong></td>
                                <td>Byte-level</td>
                                <td>Adds/subtracts small integers on 4-byte windows to trigger wraparound.</td>
                                <td>Sequence numbers, lengths, timers, signed/unsigned transitions.</td>
                                <td>Red badge + <code>arithmetic</code> pill.</td>
                            </tr>
                            <tr>
                                <td><strong>Interesting Values</strong></td>
                                <td>Byte-level</td>
                                <td>Injects canonical boundary values (0, 1, 0xFF, 0xFFFF, ...).</td>
                                <td>Off-by-one checks, sentinel comparisons, min/max validation.</td>
                                <td>Red badge + <code>interesting</code> pill.</td>
                            </tr>
                            <tr>
                                <td><strong>Havoc</strong></td>
                                <td>Byte-level</td>
                                <td>Chains inserts, deletes, flips, and shuffles for maximal chaos.</td>
                                <td>Shaking loose crashes quickly, parser robustness, state machines.</td>
                                <td>Red badge + <code>havoc</code> pill.</td>
                            </tr>
                            <tr>
                                <td><strong>Splice</strong></td>
                                <td>Corpus remix</td>
                                <td>Combines slices from multiple seeds to merge features.</td>
                                <td>Discovering emergent states that require multiple messages.</td>
                                <td>Red badge + <code>splice</code> pill.</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card">
                    <h2>Strategy Details</h2>
                    <div class="strategy-grid">
                        <div class="strategy-card structure">
                            <div class="strategy-badge structure">Structure-Aware</div>
                            <h3>Structure-Aware</h3>
                            <p>Mutations are generated through the parser/data model, so computed fields, size references, and declarative behaviors stay consistent.</p>
                            <ul>
                                <li><strong>Scope:</strong> Operates on named blocks, honoring behaviors like increment or checksum.</li>
                                <li><strong>Field detection:</strong> If `_detect_mutated_field` finds the changed block, the preview lists it.</li>
                                <li><strong>Tip:</strong> Use these samples to validate plugin wiring before unleashing raw corruption.</li>
                            </ul>
                            <div class="strategy-meta">
                                <span>UI cue: Green badge</span>
                                <span>Best for: Schema validation</span>
                            </div>
                        </div>

                        <div class="strategy-card byte">
                            <div class="strategy-badge byte">Bit Flip</div>
                            <h3>Bit Flip</h3>
                            <p>Flips single bits to create near-identical packets that still perturb critical flags.</p>
                            <ul>
                                <li>Toggles booleans, parity bits, and CRC inputs without overhauling the packet.</li>
                                <li>Great for spotting fragile checksum math or tightly-packed bitfields.</li>
                                <li>Expect payload previews that differ by only a few bits.</li>
                            </ul>
                            <div class="strategy-meta">
                                <span>UI cue: Red badge + bitflip</span>
                                <span>Best for: Flag testing</span>
                            </div>
                        </div>

                        <div class="strategy-card byte">
                            <div class="strategy-badge byte">Byte Flip</div>
                            <h3>Byte Flip</h3>
                            <p>Swaps whole bytes with random values, ignoring structure for faster coverage.</p>
                            <ul>
                                <li>Quickly corrupts opcodes, verbs, and ASCII tokens.</li>
                                <li>Useful when you want to see how resilient parsers are to garbage input.</li>
                                <li>Diffs are louder than bit flip but still localized.</li>
                            </ul>
                            <div class="strategy-meta">
                                <span>UI cue: Red badge + byteflip</span>
                                <span>Best for: Magic values</span>
                            </div>
                        </div>

                        <div class="strategy-card byte">
                            <div class="strategy-badge byte">Arithmetic</div>
                            <h3>Arithmetic</h3>
                            <p>Applies ± small integers on 32-bit windows to trigger wraparound or signedness bugs.</p>
                            <ul>
                                <li>Nudges lengths, counters, or timestamps just past safe limits.</li>
                                <li>Great for spotting insufficient bounds checks or off-by-one math.</li>
                                <li>Watch previews for incremental numeric shifts.</li>
                            </ul>
                            <div class="strategy-meta">
                                <span>UI cue: Red badge + arithmetic</span>
                                <span>Best for: Numeric fields</span>
                            </div>
                        </div>

                        <div class="strategy-card byte">
                            <div class="strategy-badge byte">Interesting Values</div>
                            <h3>Interesting Values</h3>
                            <p>Injects canonical boundary constants (0, 1, 0xFF, 0xFFFF, MAX_INT, …) into integer slots.</p>
                            <ul>
                                <li>Great at provoking off-by-one or signed/unsigned conversion bugs.</li>
                                <li>Helps confirm that size fields clamp correctly at edges.</li>
                                <li>Look for familiar constants in the payload preview.</li>
                            </ul>
                            <div class="strategy-meta">
                                <span>UI cue: Red badge + interesting</span>
                                <span>Best for: Boundary tests</span>
                            </div>
                        </div>

                        <div class="strategy-card byte">
                            <div class="strategy-badge byte">Havoc</div>
                            <h3>Havoc</h3>
                            <p>Performs 2–10 random operations (insert, delete, duplicate, shuffle, flip) per sample.</p>
                            <ul>
                                <li>Destroys structure on purpose to reach weird parser states.</li>
                                <li>Excellent once basic coverage is established and you want crashes fast.</li>
                                <li>Expect noisy previews with major length changes.</li>
                            </ul>
                            <div class="strategy-meta">
                                <span>UI cue: Red badge + havoc</span>
                                <span>Best for: Chaos testing</span>
                            </div>
                        </div>

                        <div class="strategy-card byte">
                            <div class="strategy-badge byte">Splice</div>
                            <h3>Splice</h3>
                            <p>Combines two corpus entries to merge stateful features into a single payload.</p>
                            <ul>
                                <li>Copies slices from seed A and inserts into seed B at random offsets.</li>
                                <li>Useful for protocols where meaningful states require sequences of fields.</li>
                                <li>Look for previews that mix previously-seen fragments.</li>
                            </ul>
                            <div class="strategy-meta">
                                <span>UI cue: Red badge + splice</span>
                                <span>Best for: Feature remix</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Help & Documentation</h2>
                <button class="modal-close" onclick="closeHelp()">×</button>
            </div>
            <div>
                <h3 style="color: #0066cc; margin-bottom: 15px;">Quick Links</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><a href="#" onclick="switchTab('help'); closeHelp(); return false;" style="color: #0066cc;">Getting Started Overview</a></li>
                    <li><a href="#" onclick="switchTab('protocol-guide'); closeHelp(); return false;" style="color: #0066cc;">Protocol Authoring Guide</a></li>
                    <li><a href="#" onclick="switchTab('mutation-guide'); closeHelp(); return false;" style="color: #0066cc;">Mutation Strategy Reference</a></li>
                </ul>

                <h3 style="color: #0066cc; margin-top: 30px; margin-bottom: 15px;">External Documentation</h3>
                <ul style="margin-left: 20px; line-height: 2; color: #aaa;">
                    <li><code>QUICKSTART.md</code> - Setup and deployment guide</li>
                    <li><code>CHEATSHEET.md</code> - Quick reference for commands</li>
                    <li><code>blueprint.md</code> - Architecture and design</li>
                    <li><code>roadmap.md</code> - Development phases</li>
                </ul>

                <h3 style="color: #0066cc; margin-top: 30px; margin-bottom: 15px;">Support</h3>
                <p style="color: #aaa; margin-bottom: 10px;">
                    Check Docker logs for debugging:
                </p>
                <div class="code-block">
                    <pre># View all services
docker-compose logs -f

# View specific service
docker-compose logs -f core
docker-compose logs -f target</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';
        let currentProtocolDetail = null;

        // Checkbox toggle handler
        function toggleCheckbox(element, checkboxId) {
            const checkbox = document.getElementById(checkboxId);
            checkbox.checked = !checkbox.checked;

            if (checkbox.checked) {
                element.classList.add('checked');
            } else {
                element.classList.remove('checked');
            }

            // Prevent event from bubbling to label
            updateConfigurationCoach(currentProtocolDetail);
            event.stopPropagation();
        }

        // Get selected mutators
        function getSelectedMutators() {
            const mutatorIds = [
                'mutator_bitflip',
                'mutator_byteflip',
                'mutator_arithmetic',
                'mutator_interesting',
                'mutator_havoc',
                'mutator_splice'
            ];

            const mutatorMap = {
                'mutator_bitflip': 'bitflip',
                'mutator_byteflip': 'byteflip',
                'mutator_arithmetic': 'arithmetic',
                'mutator_interesting': 'interesting',
                'mutator_havoc': 'havoc',
                'mutator_splice': 'splice'
            };

            const selected = mutatorIds
                .filter(id => document.getElementById(id).checked)
                .map(id => mutatorMap[id]);

            return selected;
        }

        // Update mutation mode UI visibility
        function updateMutationModeUI() {
            const mode = document.querySelector('input[name="mutationMode"]:checked').value;
            const weightControl = document.getElementById('hybridWeightControl');

            // Only show weight slider in hybrid mode
            if (mode === 'hybrid') {
                weightControl.style.display = 'block';
            } else {
                weightControl.style.display = 'none';
            }
        }

        // Get mutation configuration
        function getMutationConfig() {
            const mode = document.querySelector('input[name="mutationMode"]:checked').value;
            const config = {
                mutation_mode: mode
            };

            if (mode === 'hybrid') {
                config.structure_aware_weight = parseInt(document.getElementById('structureAwareWeight').value);
            }

            return config;
        }

        // Tab Management
        function switchTab(tabName, triggerEl) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.nav-tab').forEach(btn => btn.classList.remove('active'));

            const targetTab = document.getElementById(`${tabName}-tab`);
            if (targetTab) {
                targetTab.classList.add('active');
            }

            const navButton = triggerEl || document.querySelector(`.nav-tab[data-tab="${tabName}"]`);
            if (navButton) {
                navButton.classList.add('active');
            }
        }

        // Modal Management
        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        // Close modal on background click
        document.getElementById('helpModal').addEventListener('click', (e) => {
            if (e.target.id === 'helpModal') {
                closeHelp();
            }
        });

        // Load protocols on page load
        const protocolCache = {};

        async function fetchProtocolDetail(name) {
            if (!name) return null;
            if (protocolCache[name]) {
                return protocolCache[name];
            }
            const response = await fetch(`${API_BASE}/api/plugins/${name}`);
            if (!response.ok) {
                throw new Error(`Failed to load plugin ${name}`);
            }
            const detail = await response.json();
            protocolCache[name] = detail;
            return detail;
        }

        function describeBehavior(behavior) {
            if (!behavior) return '';
            const op = behavior.operation || behavior.type;
            if (op === 'increment') {
                const step = typeof behavior.step === 'number' ? behavior.step : 1;
                return `increments each send (step ${step})`;
            }
            if (op === 'add_constant') {
                const value = typeof behavior.value === 'number' ? behavior.value : 0;
                return `adds ${value} before sending`;
            }
            return op ? `custom operation: ${op}` : 'custom operation';
        }

        function getDataModel(detail) {
            if (detail && typeof detail === 'object' && detail.data_model) {
                return detail.data_model;
            }
            return {};
        }

        function getStateModel(detail) {
            if (detail && typeof detail === 'object' && detail.state_model) {
                return detail.state_model;
            }
            return {};
        }

        function getBlocks(detail) {
            const model = getDataModel(detail);
            return Array.isArray(model.blocks) ? model.blocks : [];
        }

        function getSeeds(detail) {
            const model = getDataModel(detail);
            return Array.isArray(model.seeds) ? model.seeds : [];
        }

        function isBlockFuzzable(block) {
            if (!block) return false;
            if (block.mutable === false) return false;
            if (block.is_size_field) return false;
            const behavior = block.behavior && typeof block.behavior === 'object' ? block.behavior : null;
            const op = behavior && behavior.operation;
            if (op === 'checksum') return false;
            return true;
        }

        function formatBlockSize(block) {
            if (!block) return 'variable';
            if (block.size) {
                return `${block.size} bytes`;
            }
            if (block.max_size) {
                return `≤ ${block.max_size} bytes`;
            }
            if (block.type && block.type.toLowerCase().startsWith('uint')) {
                return block.type.toUpperCase();
            }
            return 'dynamic';
        }

        function tryBase64Decode(value) {
            try {
                const binary = atob(value);
                const reencoded = btoa(binary);
                if (reencoded.replace(/=+$/, '') === value.replace(/=+$/, '')) {
                    return Array.from(binary, ch => ch.charCodeAt(0));
                }
            } catch (error) {
                return null;
            }
            return null;
        }

        function asByteArray(value) {
            if (!value) return [];
            if (Array.isArray(value)) return value;
            if (typeof value === 'string') {
                const decoded = tryBase64Decode(value);
                if (decoded) {
                    return decoded;
                }
                return Array.from(value, ch => ch.charCodeAt(0));
            }
            if (typeof value === 'number') {
                return [value & 0xff];
            }
            return [];
        }

        function formatHexPreview(bytes, maxBytes = 32) {
            if (!bytes || !bytes.length) return '(empty)';
            const slice = bytes.slice(0, maxBytes);
            const hex = slice.map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ');
            return bytes.length > maxBytes ? `${hex} …` : hex;
        }

        function createSyntheticBytes(block, variantSeed = 0, mutated = false) {
            const defaultValue = block ? block.default : undefined;
            const useDefault = !mutated && defaultValue;
            if (useDefault) {
                const defaultBytes = asByteArray(defaultValue);
                if (defaultBytes.length) {
                    return defaultBytes;
                }
            }
            const size = block && typeof block.size === 'number' ? block.size : null;
            const maxSize = block && typeof block.max_size === 'number' ? block.max_size : null;
            const length = size || Math.min(maxSize || 12, 16);
            const name = (block && block.name) || 'block';
            const bytes = [];
            for (let i = 0; i < length; i++) {
                const baseChar = name.charCodeAt((i + variantSeed) % name.length) || 65;
                const noise = mutated ? (variantSeed + 1) * 17 : 7;
                bytes.push((baseChar + noise + i * (mutated ? 23 : 9)) % 256);
            }
            return bytes;
        }

        function formatNumeric(value, bits) {
            if (typeof value !== 'number' || !Number.isFinite(value)) {
                return value && value.toString ? value.toString() : '0x0';
            }
            const width = Math.max(Math.ceil(bits / 4), 2);
            const normalized = value >>> 0;
            return `0x${normalized.toString(16).toUpperCase().padStart(width, '0')}`;
        }

        function computeBlockValue(block, { mutated = false, variantIndex = 0, blocks = null } = {}) {
            if (!block) return 'n/a';
            const type = (block.type || '').toLowerCase();

            // Handle size fields - compute actual size of referenced block
            if (block.is_size_field && block.size_of && blocks) {
                const targetBlock = blocks.find(b => b.name === block.size_of);
                if (targetBlock) {
                    let computedSize = 0;
                    const targetType = (targetBlock.type || '').toLowerCase();

                    if (targetBlock.size) {
                        computedSize = targetBlock.size;
                    } else if (targetType === 'bytes') {
                        const bytes = createSyntheticBytes(targetBlock, variantIndex, mutated);
                        computedSize = bytes.length;
                    } else if (targetType.startsWith('uint') || targetType.startsWith('int')) {
                        const bits = parseInt(targetType.replace(/[a-z]+/, ''), 10) || 8;
                        computedSize = Math.ceil(bits / 8);
                    } else if (targetType === 'string') {
                        const str = typeof targetBlock.default === 'string' ? targetBlock.default : '';
                        computedSize = str.length;
                    }

                    const bits = parseInt(type.replace('uint', ''), 10) || 32;
                    if (!mutated) {
                        return `${formatNumeric(computedSize, bits)} (→${block.size_of})`;
                    } else {
                        // When mutating size fields, show boundary values
                        const interesting = [0, 1, computedSize, Math.pow(2, Math.min(bits, 16)) - 1];
                        const candidate = interesting[variantIndex % interesting.length];
                        return `${formatNumeric(candidate, bits)} (boundary →${block.size_of})`;
                    }
                }
            }

            if (type.startsWith('uint')) {
                const bits = parseInt(type.replace('uint', ''), 10) || 8;
                const values = block.values ? Object.keys(block.values).map(Number).filter(v => !Number.isNaN(v)) : [];
                const defaultValue = typeof block.default === 'number' ? block.default : (values.length ? values[0] : 0);
                if (!mutated) {
                    return formatNumeric(defaultValue, bits);
                }
                const interesting = [1, Math.max(1, Math.pow(2, Math.min(bits, 30)) - 1)];
                const candidate = interesting[variantIndex % interesting.length];
                return `${formatNumeric(candidate, bits)} (boundary)`;
            }
            if (type === 'string') {
                const base = typeof block.default === 'string' ? block.default : (block.name || 'field');
                return mutated ? `${base}_fuzz` : base;
            }
            if (type === 'bytes') {
                const bytes = createSyntheticBytes(block, variantIndex, mutated);
                return formatHexPreview(bytes);
            }
            return mutated ? 'mutated value' : 'default value';
        }

        function mutationNote(block) {
            if (!block) return 'General mutation applied.';
            if (block.values && Object.keys(block.values).length > 1) {
                return 'Switches between documented opcodes to verify alternate handlers.';
            }
            if (block.is_size_field) {
                return 'Pushes reported lengths to stress parser bounds (dependent fields auto-updated).';
            }
            if ((block.type || '').toLowerCase() === 'bytes') {
                return 'Injects high-entropy payload bytes to explore parser states.';
            }
            const behavior = block && block.behavior && typeof block.behavior === 'object' ? block.behavior : null;
            if (behavior && behavior.operation === 'increment') {
                return 'Sequence counters continue to increment while payload fields mutate.';
            }
            return 'Applies boundary values to this numeric field to surface logic bugs.';
        }

        function buildMessagePreview(blocks, focusName, variantIndex) {
            if (!blocks || !blocks.length) {
                return '<span class="empty-state">No blocks defined.</span>';
            }
            return blocks.map(block => {
                const mutated = block.name === focusName;
                const value = computeBlockValue(block, { mutated, variantIndex });
                const cls = mutated ? 'message-segment mutated' : 'message-segment';
                return `<span class="${cls}"><strong>${block.name || 'field'}</strong>: ${value}</span>`;
            }).join('');
        }

        function renderProtocolBlueprint(detail) {
            const diagram = document.getElementById('protocolDiagram');
            const meta = document.getElementById('protocolBlueprintMeta');
            if (!diagram) return;
            if (!detail) {
                diagram.classList.add('empty-state');
                diagram.textContent = 'Select a protocol to visualize its blocks.';
                if (meta) meta.textContent = '';
                return;
            }
            const dataModel = detail && detail.data_model ? detail.data_model : {};
            const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
            const fuzzableCount = blocks.filter(isBlockFuzzable).length;
            if (meta) {
                meta.textContent = blocks.length ? `${blocks.length} block${blocks.length === 1 ? '' : 's'} · ${fuzzableCount} fuzzable` : '';
            }
            if (!blocks.length) {
                diagram.classList.add('empty-state');
                diagram.textContent = 'Protocol has no blocks defined yet.';
                return;
            }
            diagram.classList.remove('empty-state');
            diagram.innerHTML = `
                <div class="protocol-blocks">
                    ${blocks.map(block => {
                        const flags = [];
                        if (isBlockFuzzable(block)) {
                            flags.push('<span class="flag-pill">fuzzable</span>');
                        } else {
                            flags.push('<span class="flag-pill">derived</span>');
                        }
                        if (block.mutable === false) {
                            flags.push('<span class="flag-pill">locked</span>');
                        }
                        if (block.is_size_field) {
                            flags.push('<span class="flag-pill">size field</span>');
                        }
                        if (block.behavior) {
                            flags.push(`<span class="flag-pill behavior">${describeBehavior(block.behavior)}</span>`);
                        }
                        const classes = ['protocol-block', isBlockFuzzable(block) ? 'fuzzable' : 'locked'].join(' ');
                        return `
                            <div class="${classes}">
                                <div class="protocol-block-header">
                                    <span class="block-name">${block.name || 'unnamed'}</span>
                                    <span class="block-type">${(block.type || 'custom').toUpperCase()}</span>
                                </div>
                                <div class="block-meta">
                                    <span>${formatBlockSize(block)}</span>
                                    ${block.size_of ? `<span>controls ${block.size_of}</span>` : ''}
                                </div>
                                ${flags.length ? `<div class="block-flags">${flags.join('')}</div>` : ''}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function renderStateMachineDiagram(stateMachine) {
            const { initial_state, states, transitions, message_type_to_command } = stateMachine;

            // Build transition map for rendering
            const transitionsByState = {};
            transitions.forEach(trans => {
                if (!transitionsByState[trans.from_state]) {
                    transitionsByState[trans.from_state] = [];
                }
                transitionsByState[trans.from_state].push(trans);
            });

            // Render state boxes
            const stateBoxes = states.map(state => {
                const isInitial = state === initial_state;
                const outgoingTransitions = transitionsByState[state] || [];

                const transitionsHtml = outgoingTransitions.map(trans => {
                    const cmdValue = message_type_to_command[trans.message_type];
                    const cmdHex = cmdValue !== undefined ? ` (0x${cmdValue.toString(16).toUpperCase().padStart(2, '0')})` : '';
                    return `
                        <div class="state-transition-item">
                            <span class="transition-message">${trans.message_type}${cmdHex}</span>
                            <span class="transition-arrow-simple">→</span>
                            <span class="transition-target">${trans.to_state}</span>
                            ${trans.expected_response ? `<span class="transition-response">expects: ${trans.expected_response}</span>` : ''}
                        </div>
                    `;
                }).join('');

                return `
                    <div class="state-box ${isInitial ? 'state-initial' : ''}">
                        <div class="state-name">
                            ${isInitial ? '<span class="initial-badge">INITIAL</span>' : ''}
                            ${state}
                        </div>
                        ${transitionsHtml ? `<div class="state-transitions">${transitionsHtml}</div>` : '<div class="state-terminal">Terminal State</div>'}
                    </div>
                `;
            }).join('');

            return `
                <div class="state-machine-diagram">
                    <p class="state-machine-note">The fuzzer follows valid transitions per session. Fields below show outgoing paths and expected responses where provided.</p>
                    <div class="state-flow">
                        ${stateBoxes}
                    </div>
                </div>
            `;
        }

        function updateStateMachinePanel(stateMachine) {
            const container = document.getElementById('stateMachinePanel');
            const meta = document.getElementById('stateMachineMeta');
            if (!container) {
                return;
            }

            if (!stateMachine || !stateMachine.has_state_model) {
                container.classList.add('empty-state');
                container.innerHTML = 'No state machine defined for this protocol yet.';
                if (meta) meta.textContent = '';
                return;
            }

            container.classList.remove('empty-state');
            container.innerHTML = renderStateMachineDiagram(stateMachine);

            if (meta) {
                const stateCount = Array.isArray(stateMachine.states) ? stateMachine.states.length : 0;
                const transitionCount = Array.isArray(stateMachine.transitions) ? stateMachine.transitions.length : 0;
                meta.textContent = `${stateCount} state${stateCount === 1 ? '' : 's'} · ${transitionCount} transition${transitionCount === 1 ? '' : 's'}`;
            }
        }

        async function renderTestCaseSamples(detail) {
            const seedContainer = document.getElementById('seedSampleList');
            const mutationContainer = document.getElementById('mutationPreviewList');
            const meta = document.getElementById('sampleCorpusMeta');
            if (!seedContainer || !mutationContainer) return;
            if (!detail) {
                seedContainer.innerHTML = '<p class="empty-state">Provide seeds inside your plugin to preview baseline requests.</p>';
                mutationContainer.innerHTML = '<p class="empty-state">Select a protocol to generate sample mutation plans.</p>';
                if (meta) meta.textContent = '';
                updateStateMachinePanel(null);
                return;
            }

            const protocolName = detail.name;
            const dataModel = detail && detail.data_model ? detail.data_model : {};
            const seeds = Array.isArray(dataModel.seeds) ? dataModel.seeds : [];

            if (meta) {
                meta.textContent = seeds.length ? `${seeds.length} seed${seeds.length === 1 ? '' : 's'} detected` : 'No corpus seeds yet';
            }

            // Render seed previews (still using local logic for simple display)
            if (!seeds.length) {
                seedContainer.innerHTML = '<p class="empty-state">No seeds defined. Add data_model.seeds to preview corpus examples.</p>';
            } else {
                seedContainer.innerHTML = seeds.slice(0, 3).map((seed, idx) => {
                    const bytes = asByteArray(seed);
                    return `
                        <div class="seed-chip">
                            <span>Seed ${idx + 1} · ${bytes.length} bytes</span>
                            <code>${formatHexPreview(bytes)}</code>
                        </div>
                    `;
                }).join('');
                if (seeds.length > 3) {
                    seedContainer.innerHTML += `<div class="field-help">+ ${seeds.length - 3} additional seed${seeds.length - 3 === 1 ? '' : 's'} hidden</div>`;
                }
            }

            // Check if there are fuzzable blocks
            const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
            const fuzzableBlocks = blocks.filter(isBlockFuzzable);
            if (!fuzzableBlocks.length) {
                mutationContainer.innerHTML = '<p class="empty-state">No fuzzable blocks detected. Mark fields as mutable to preview mutation plans.</p>';
                return;
            }

            // Use backend API to generate mutation previews (shows actual fuzzer output)
            try {
                mutationContainer.innerHTML = '<p class="empty-state">Generating mutation previews...</p>';
                const statePanel = document.getElementById('stateMachinePanel');
                if (statePanel) {
                    statePanel.classList.remove('empty-state');
                    statePanel.innerHTML = '<p class="empty-state">Loading state machine diagram...</p>';
                }

                const response = await fetch(`${API_BASE}/api/plugins/${protocolName}/preview`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        mode: 'mutations',
                        count: 6
                    })
                });

                if (!response.ok) {
                    throw new Error(`Preview generation failed: ${response.statusText}`);
                }

                const data = await response.json();

                updateStateMachinePanel(data.state_machine);

                const previewsHtml = data.previews.map(preview => {
                    // Build mutator badges
                    let mutatorBadges = '';
                    if (preview.mutators_used && preview.mutators_used.length > 0) {
                        const mutatorClass = preview.mutation_type === 'structure_aware' ? 'mutator-badge-structure' : 'mutator-badge-byte';
                        mutatorBadges = preview.mutators_used.map(m =>
                            `<span class="mutator-badge ${mutatorClass}">${m}</span>`
                        ).join('');
                    }

                    // Build mutation type badge
                    let typeBadge = '';
                    if (preview.mutation_type) {
                        const typeClass = preview.mutation_type === 'structure_aware' ? 'type-badge-structure' : 'type-badge-byte';
                        const typeLabel = preview.mutation_type === 'structure_aware' ? 'Structure-Aware' : 'Byte-Level';
                        typeBadge = `<span class="type-badge ${typeClass}">${typeLabel}</span>`;
                    }

                    // Build description
                    let descriptionHtml = '';
                    if (preview.description) {
                        descriptionHtml = `<div class="mutation-description">${preview.description}</div>`;
                    }

                    // Build state transition info
                    let stateInfoHtml = '';
                    if (preview.message_type) {
                        stateInfoHtml = `
                            <div class="state-transition-info">
                                <span class="state-label">Message Type:</span>
                                <span class="message-type-badge">${preview.message_type}</span>
                                ${preview.valid_in_state ? `<span class="state-label">Valid in:</span> <span class="state-badge">${preview.valid_in_state}</span>` : ''}
                                ${preview.causes_transition ? `<span class="transition-arrow">${preview.causes_transition}</span>` : ''}
                            </div>
                        `;
                    }

                    const fieldsHtml = preview.fields.map(field => {
                        const computedBadge = field.computed ? `<span class="computed-badge">→${field.references}</span>` : '';
                        const mutatedClass = field.mutated ? 'mutated' : '';
                        const valueDisplay = typeof field.value === 'number' ? `0x${field.value.toString(16).toUpperCase().padStart(2, '0')}` : field.value;
                        return `
                            <div class="field-item ${mutatedClass}">
                                <strong>${field.name}</strong>: ${valueDisplay} ${computedBadge}
                            </div>
                        `;
                    }).join('');

                    return `
                        <div class="sample-case ${preview.mutation_type ? 'sample-case-' + preview.mutation_type : ''}">
                            <div class="sample-case-header">
                                <span>Case ${preview.id + 1} · ${preview.total_bytes} bytes</span>
                                <div class="badge-group">
                                    ${typeBadge}
                                    ${mutatorBadges}
                                </div>
                            </div>
                            <div class="sample-case-body">
                                ${descriptionHtml}
                                ${stateInfoHtml}
                                <div class="hex-preview">${formatHexPreview(hexStringToBytes(preview.hex_dump), 32)}</div>
                                <div class="field-breakdown">${fieldsHtml}</div>
                            </div>
                        </div>
                    `;
                }).join('');

                mutationContainer.innerHTML = previewsHtml;

            } catch (error) {
                mutationContainer.innerHTML = `<p class="empty-state">Failed to generate previews: ${error.message}</p>`;
                updateStateMachinePanel(null);
                console.error('Preview generation error:', error);
            }
        }

        function hexStringToBytes(hexString) {
            const bytes = [];
            for (let i = 0; i < hexString.length; i += 2) {
                bytes.push(parseInt(hexString.substr(i, 2), 16));
            }
            return bytes;
        }

        function updateConfigurationCoach(detail) {
            const container = document.getElementById('configurationCoach');
            if (!container) return;
            const hostInput = document.getElementById('targetHost');
            const portInput = document.getElementById('targetPort');
            const host = hostInput ? hostInput.value.trim() : '';
            const port = portInput ? portInput.value.trim() : '';
            const dataModel = detail && detail.data_model ? detail.data_model : {};
            const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
            const seeds = Array.isArray(dataModel.seeds) ? dataModel.seeds : [];
            const fuzzableBlocks = blocks.filter(isBlockFuzzable);
            const mutators = getSelectedMutators();
            const items = [
                {
                    label: 'Protocol blueprint',
                    status: detail ? 'ready' : 'pending',
                    message: detail ? `${blocks.length} block${blocks.length === 1 ? '' : 's'} detected` : 'Select a protocol plugin to inspect structure.',
                },
                {
                    label: 'Seed corpus',
                    status: seeds.length ? 'ready' : 'warn',
                    message: seeds.length ? `${seeds.length} sample${seeds.length === 1 ? '' : 's'} available` : 'Add data_model.seeds for faster convergence.',
                },
                {
                    label: 'Fuzzable coverage',
                    status: fuzzableBlocks.length ? 'ready' : 'warn',
                    message: fuzzableBlocks.length ? fuzzableBlocks.map(b => b.name).join(', ') : 'All blocks currently locked or derived.',
                },
                {
                    label: 'Mutation plan',
                    status: mutators.length ? 'ready' : 'error',
                    message: mutators.length ? mutators.join(', ') : 'Enable ≥1 mutation strategy.',
                },
                {
                    label: 'Target endpoint',
                    status: host && port ? 'ready' : 'pending',
                    message: host && port ? `${host}:${port}` : 'Provide host & port before launching.',
                },
            ];
            container.innerHTML = items.map(item => `
                <div class="coach-item">
                    <div>
                        <div class="coach-label">${item.label}</div>
                        <div class="coach-message">${item.message}</div>
                    </div>
                    <span class="coach-status ${item.status}">${item.status}</span>
                </div>
            `).join('');

            let tip = 'Ready to fuzz once each row turns green.';
            if (!detail) {
                tip = 'Tip: select a protocol to unlock visualization and previews.';
            } else if (!seeds.length) {
                tip = 'Tip: define at least one seed so the engine can preview baseline requests here.';
            } else if (!fuzzableBlocks.length) {
                tip = 'Tip: mark non-derived blocks as mutable so the fuzzer can touch them.';
            } else if (!host || !port) {
                tip = 'Tip: point the session at a reachable host/port (try make run-target).';
            }
            container.innerHTML += `<div class="coach-tip">${tip}</div>`;
        }

        async function handleProtocolChange(protocolName) {
            if (!protocolName) {
                currentProtocolDetail = null;
                renderProtocolBlueprint(null);
                renderTestCaseSamples(null);
                updateBehaviorSummary(null);
                updateConfigurationCoach(null);
                updateStateMachinePanel(null);
                return;
            }
            try {
                const detail = await fetchProtocolDetail(protocolName);
                currentProtocolDetail = detail;
                updateBehaviorSummary(protocolName, detail);
                renderProtocolBlueprint(detail);
                await renderTestCaseSamples(detail);
                updateConfigurationCoach(detail);
            } catch (error) {
                currentProtocolDetail = null;
                renderProtocolBlueprint(null);
                await renderTestCaseSamples(null);
                updateBehaviorSummary(null);
                updateConfigurationCoach(null);
                updateStateMachinePanel(null);
                showMessage('Failed to load protocol detail: ' + error.message, 'error');
            }
        }

        async function updateBehaviorSummary(protocolName, detailOverride) {
            const summary = document.getElementById('behaviorSummary');
            if (!protocolName) {
                summary.textContent = 'Select a protocol to view automatic field behaviors.';
                return;
            }
            try {
                const detail = detailOverride || await fetchProtocolDetail(protocolName);
                const dataModel = detail && detail.data_model ? detail.data_model : {};
                const blocks = Array.isArray(dataModel.blocks) ? dataModel.blocks : [];
                const behaviors = blocks.filter(block => block.behavior);
                if (!behaviors.length) {
                    summary.textContent = 'No automatic field behaviors defined in this plugin.';
                    return;
                }
                const items = behaviors
                    .map(block => `<li><strong>${block.name}</strong> — ${describeBehavior(block.behavior)}</li>`)
                    .join('');
                summary.innerHTML = `<span>Automatic operations applied before each message:</span><ul>${items}</ul>`;
            } catch (error) {
                summary.textContent = `Unable to load behavior details: ${error.message}`;
            }
        }

        // One-Off Test Functions
        function updatePayloadPlaceholder() {
            const format = document.getElementById('oneoffPayloadFormat').value;
            const textarea = document.getElementById('oneoffPayload');
            const helpText = document.getElementById('oneoffPayloadHelp');

            if (format === 'hex') {
                textarea.placeholder = '53 54 43 50 00 00 00 05 01 48 45 4c 4c 4f';
                helpText.textContent = 'Enter hex bytes (space-separated). Example SimpleTCP AUTH: "53 54 43 50 00 00 00 05 01 48 45 4c 4c 4f"';
            } else if (format === 'base64') {
                textarea.placeholder = 'U1RDUALAAAUFAUZFTEXM=';
                helpText.textContent = 'Enter base64-encoded binary data';
            } else {
                textarea.placeholder = 'Hello World';
                helpText.textContent = 'Enter plain text (will be UTF-8 encoded)';
            }
        }

        function hexToBytes(hexString) {
            // Remove spaces and convert to byte array
            const hex = hexString.replace(/\s+/g, '');
            const bytes = [];
            for (let i = 0; i < hex.length; i += 2) {
                bytes.push(parseInt(hex.substr(i, 2), 16));
            }
            return new Uint8Array(bytes);
        }

        function base64ToBytes(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes;
        }

        function textToBytes(text) {
            return new TextEncoder().encode(text);
        }

        function bytesToHex(bytes) {
            return Array.from(bytes)
                .map(b => b.toString(16).padStart(2, '0').toUpperCase())
                .join(' ');
        }

        function bytesToAscii(bytes) {
            return Array.from(bytes)
                .map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.')
                .join('');
        }

        async function executeOneOffTest(event) {
            event.preventDefault();

            const protocol = document.getElementById('oneoffProtocol').value;
            const targetHost = document.getElementById('oneoffTargetHost').value;
            const targetPort = parseInt(document.getElementById('oneoffTargetPort').value);
            const payloadFormat = document.getElementById('oneoffPayloadFormat').value;
            const payloadInput = document.getElementById('oneoffPayload').value.trim();
            const timeout = parseInt(document.getElementById('oneoffTimeout').value);

            const submitBtn = document.getElementById('oneoffSubmitBtn');
            const resultsDiv = document.getElementById('oneoffResults');

            // Hide previous results
            resultsDiv.style.display = 'none';
            document.getElementById('oneoffResponseSection').style.display = 'none';
            document.getElementById('oneoffErrorSection').style.display = 'none';
            document.getElementById('oneoffCrashSection').style.display = 'none';

            // Validate inputs
            if (!protocol || !targetHost || !targetPort || !payloadInput) {
                showMessage('Please fill in all required fields', 'error');
                return;
            }

            // Convert payload to bytes based on format
            let payloadBytes;
            try {
                if (payloadFormat === 'hex') {
                    payloadBytes = hexToBytes(payloadInput);
                } else if (payloadFormat === 'base64') {
                    payloadBytes = base64ToBytes(payloadInput);
                } else {
                    payloadBytes = textToBytes(payloadInput);
                }
            } catch (error) {
                showMessage(`Invalid ${payloadFormat} format: ${error.message}`, 'error');
                return;
            }

            // Convert to base64 for API
            const payloadBase64 = btoa(String.fromCharCode(...payloadBytes));

            // Disable submit button
            submitBtn.disabled = true;
            submitBtn.textContent = '⏳ Sending...';

            try {
                const response = await fetch(`${API_BASE}/api/tests/execute`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        protocol: protocol,
                        target_host: targetHost,
                        target_port: targetPort,
                        payload: payloadBase64,
                        timeout_ms: timeout
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Test execution failed');
                }

                const result = await response.json();

                // Show results
                resultsDiv.style.display = 'block';

                // Update result status
                const statusEl = document.getElementById('oneoffResultStatus');
                statusEl.textContent = result.result.toUpperCase();
                statusEl.className = 'stat-value';

                if (result.result === 'pass') {
                    statusEl.style.color = '#4caf50';
                } else if (result.result === 'crash') {
                    statusEl.style.color = '#ff5252';
                } else if (result.result === 'hang') {
                    statusEl.style.color = '#ff9800';
                } else {
                    statusEl.style.color = '#ffd700';
                }

                // Update execution time
                document.getElementById('oneoffResultTime').textContent = result.execution_time_ms.toFixed(2) + ' ms';

                // Update response size
                const responseSize = result.response ? atob(result.response).length : 0;
                document.getElementById('oneoffResultSize').textContent = responseSize + ' bytes';

                // Show response if available
                if (result.response) {
                    const responseBytes = base64ToBytes(result.response);
                    document.getElementById('oneoffResponseHex').textContent = bytesToHex(responseBytes);
                    document.getElementById('oneoffResponseAscii').textContent = bytesToAscii(responseBytes);
                    document.getElementById('oneoffResponseSection').style.display = 'block';
                }

                // Show crash info if crash occurred
                if (result.result === 'crash' && result.crash_report_id) {
                    document.getElementById('oneoffCrashId').textContent = result.crash_report_id;
                    document.getElementById('oneoffCrashSection').style.display = 'block';
                }

                // Show any metadata errors
                if (result.metadata && result.metadata.error) {
                    document.getElementById('oneoffErrorText').textContent = result.metadata.error;
                    document.getElementById('oneoffErrorSection').style.display = 'block';
                }

                showMessage('✅ Test executed successfully!', 'success');

            } catch (error) {
                showMessage('❌ Test execution failed: ' + error.message, 'error');

                // Show error in results section
                resultsDiv.style.display = 'block';
                document.getElementById('oneoffErrorText').textContent = error.message;
                document.getElementById('oneoffErrorSection').style.display = 'block';
                document.getElementById('oneoffResultStatus').textContent = 'ERROR';
                document.getElementById('oneoffResultStatus').style.color = '#ff5252';
            } finally {
                // Re-enable submit button
                submitBtn.disabled = false;
                submitBtn.textContent = '🚀 Send Test Message';
            }
        }

        async function loadProtocols() {
            try {
                const response = await fetch(`${API_BASE}/api/plugins`);
                const protocols = await response.json();
                const sessionSelect = document.getElementById('protocol');
                const debuggerSelect = document.getElementById('pluginDebugProtocol');
                const oneoffSelect = document.getElementById('oneoffProtocol');

                const optionsHtml = protocols.map(p => `<option value="${p}">${p}</option>`).join('');

                if (sessionSelect) {
                    sessionSelect.innerHTML = protocols.length
                        ? optionsHtml
                        : '<option value="">No plugins found</option>';
                }

                if (debuggerSelect) {
                    debuggerSelect.innerHTML = '<option value="">Select a protocol to inspect…</option>' + optionsHtml;
                }

                if (oneoffSelect) {
                    oneoffSelect.innerHTML = protocols.length
                        ? optionsHtml
                        : '<option value="">No plugins found</option>';
                }

                if (protocols.length && debuggerSelect) {
                    const current = debuggerSelect.value;
                    if (!current || !protocols.includes(current)) {
                        debuggerSelect.value = protocols[0];
                    }
                    await handleProtocolChange(debuggerSelect.value);
                } else {
                    handleProtocolChange(null);
                }
            } catch (error) {
                showMessage('Failed to load protocols: ' + error.message, 'error');
            }
        }

        const pluginDebugSelect = document.getElementById('pluginDebugProtocol');
        if (pluginDebugSelect) {
            pluginDebugSelect.addEventListener('change', (e) => {
                handleProtocolChange(e.target.value);
            });
        }

        // Reload plugin button
        const reloadPluginBtn = document.getElementById('reloadPluginBtn');
        if (reloadPluginBtn) {
            reloadPluginBtn.addEventListener('click', async () => {
                const currentProtocol = pluginDebugSelect ? pluginDebugSelect.value : null;
                if (!currentProtocol) {
                    showMessage('⚠️ Please select a protocol first', 'error');
                    return;
                }

                // Disable button and show loading state
                reloadPluginBtn.disabled = true;
                reloadPluginBtn.classList.add('loading');
                reloadPluginBtn.innerHTML = '<span class="reload-icon">⟳</span> Reloading...';

                try {
                    const response = await fetch(`${API_BASE}/api/plugins/${currentProtocol}/reload`, {
                        method: 'POST'
                    });

                    if (response.ok) {
                        const plugin = await response.json();
                        showMessage(`✓ Protocol "${currentProtocol}" reloaded successfully!`, 'success');

                        // IMPORTANT: Clear the cache for this protocol to force fresh data
                        if (typeof protocolCache !== 'undefined' && protocolCache[currentProtocol]) {
                            delete protocolCache[currentProtocol];
                        }

                        // Refresh the debugger panels with new data
                        await handleProtocolChange(currentProtocol);
                    } else {
                        const error = await response.json();
                        showMessage(`✗ Failed to reload: ${error.detail || 'Unknown error'}`, 'error');
                    }
                } catch (error) {
                    showMessage(`✗ Reload error: ${error.message}`, 'error');
                } finally {
                    // Re-enable button and restore normal state
                    reloadPluginBtn.disabled = false;
                    reloadPluginBtn.classList.remove('loading');
                    reloadPluginBtn.innerHTML = '<span class="reload-icon">⟳</span> Reload';
                }
            });
        }

        // Create session
        document.getElementById('createSessionForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const selectedMutators = getSelectedMutators();

            // Validate at least one mutator is selected
            if (selectedMutators.length === 0) {
                showMessage('⚠️ Please select at least one mutation strategy', 'error');
                return;
            }

            const rateLimit = parseInt(document.getElementById('rateLimit').value);
            const mutationConfig = getMutationConfig();

            const config = {
                protocol: document.getElementById('protocol').value,
                target_host: document.getElementById('targetHost').value,
                target_port: parseInt(document.getElementById('targetPort').value),
                enabled_mutators: selectedMutators,
                ...mutationConfig  // Spread mutation mode config
            };

            // Only include rate_limit_per_second if it's non-zero
            if (rateLimit > 0) {
                config.rate_limit_per_second = rateLimit;
            }

            try {
                const response = await fetch(`${API_BASE}/api/sessions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(config)
                });

                if (response.ok) {
                    const session = await response.json();
                    showMessage(`✓ Session created with ${selectedMutators.length} mutator(s)! Click "Start" to begin fuzzing.`, 'success');
                    loadSessions();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to create session: ' + error.message, 'error');
            }
        });

        ['targetHost', 'targetPort'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('input', () => updateConfigurationCoach(currentProtocolDetail));
            }
        });

        document.querySelectorAll('.checkbox-group input[type="checkbox"]').forEach(input => {
            input.addEventListener('change', () => updateConfigurationCoach(currentProtocolDetail));
        });

        // Load sessions
        async function loadSessions() {
            try {
                const response = await fetch(`${API_BASE}/api/sessions`);
                const sessions = await response.json();

                const container = document.getElementById('sessions');
                if (sessions.length === 0) {
                    container.innerHTML = '<p class="loading">No active sessions. Create one above to get started!</p>';
                } else {
                    container.innerHTML = sessions.map(s => `
                        <div class="session-item">
                            <div class="session-header">
                                <div class="session-info">
                                    <strong>${s.protocol}</strong> → ${s.target_host}:${s.target_port}
                                    <br>
                                    <span class="status-badge status-${s.status}">${s.status}</span>
                                    <small style="color: #888; margin-left: 10px;">
                                        ${s.status === 'running' ? 'Actively fuzzing…' :
                                          s.status === 'idle' ? 'Ready to start' :
                                          s.status === 'completed' ? 'Session completed' :
                                          s.status === 'failed' ? 'Session failed' : ''}
                                    </small>
                                </div>
                                <div class="session-actions">
                                    ${s.status === 'idle' ?
                                        `<button onclick="startSession('${s.id}')" title="Start sending fuzzed inputs to target">Start</button>` :
                                        s.status === 'running' ?
                                        `<button class="danger" onclick="stopSession('${s.id}')" title="Stop fuzzing campaign">Stop</button>` :
                                        s.status === 'failed' ?
                                        `<button class="secondary" onclick="deleteSession('${s.id}')" title="Remove this session">Delete</button>` :
                                        ''
                                    }
                                </div>
                            </div>
                            ${s.error_message ? `
                                <div class="error" style="margin-top: 10px; font-size: 13px;">
                                    <strong>Error:</strong> ${s.error_message}
                                </div>
                            ` : ''}
                            ${s.enabled_mutators && s.enabled_mutators.length > 0 ? `
                                <div style="margin-top: 10px; font-size: 12px; color: #888;">
                                    <strong>Mutators:</strong> ${s.enabled_mutators.join(', ')}
                                    ${s.rate_limit_per_second && s.rate_limit_per_second > 0 ?
                                        ` | <strong>Rate:</strong> ${s.rate_limit_per_second} tests/sec` :
                                        ' | <strong>Rate:</strong> Unlimited'}
                                </div>
                            ` : ''}
                            ${s.mutation_mode ? `
                                <div style="margin-top: 5px; font-size: 12px; color: #4a9eff;">
                                    <strong>Mutation:</strong> ${s.mutation_mode === 'hybrid' ? 'Hybrid' : s.mutation_mode === 'structure_aware' ? 'Structure-Aware' : 'Byte-Level'}
                                    ${s.mutation_mode === 'hybrid' && s.structure_aware_weight ? ` (${s.structure_aware_weight}% structure-aware)` : ''}
                                </div>
                            ` : ''}
                            <div class="session-details">
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Total Tests</div>
                                    <div class="session-detail-value">${s.total_tests.toLocaleString()}</div>
                                    <span class="tooltiptext">
                                        Number of mutated inputs sent to target in this session.
                                        Each test applies mutation strategies (bit flip, arithmetic, etc.)
                                        to seed corpus. More tests = more thorough fuzzing.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Crashes</div>
                                    <div class="session-detail-value" style="color: ${s.crashes > 0 ? '#cc0000' : '#fff'}">${s.crashes}</div>
                                    <span class="tooltiptext">
                                        Program crashes detected. Includes connection failures,
                                        segmentation faults, and abnormal terminations. Each crash
                                        is a potential security vulnerability. Saved in data/crashes/.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Hangs</div>
                                    <div class="session-detail-value" style="color: ${s.hangs > 0 ? '#ff9900' : '#fff'}">${s.hangs}</div>
                                    <span class="tooltiptext">
                                        Timeout events where target stopped responding. May indicate
                                        infinite loops, deadlocks, or resource exhaustion. Timeout
                                        threshold: 5 seconds (configurable). Can lead to DoS.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Anomalies</div>
                                    <div class="session-detail-value" style="color: ${s.anomalies > 0 ? '#ffcc00' : '#fff'}">${s.anomalies}</div>
                                    <span class="tooltiptext">
                                        Logical failures detected by validator oracles. Target
                                        didn't crash but returned invalid/unexpected responses.
                                        Examples: negative balance, wrong state, invalid format.
                                        Check validator in protocol plugin.
                                    </span>
                                </div>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (error) {
                document.getElementById('sessions').innerHTML =
                    `<p class="error">Failed to load sessions: ${error.message}</p>`;
            }
        }

        // Start session
        async function startSession(sessionId) {
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${sessionId}/start`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showMessage('✓ Fuzzing started! Monitor the statistics below.', 'success');
                    loadSessions();
                    startStatsPolling();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to start session: ' + error.message, 'error');
            }
        }

        // Stop session
        async function stopSession(sessionId) {
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${sessionId}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showMessage('✓ Fuzzing session stopped. Check findings in data/crashes/.', 'info');
                    loadSessions();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to stop session: ' + error.message, 'error');
            }
        }

        // Delete session
        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                return;
            }

            // For now, just hide it from UI (full implementation would call DELETE endpoint)
            showMessage('Session removed from view. Refresh page to see all sessions.', 'info');
            loadSessions();
        }

        // Update system stats
        async function updateStats() {
            try {
                const [health, corpus, sessions] = await Promise.all([
                    fetch(`${API_BASE}/api/system/health`).then(r => r.json()),
                    fetch(`${API_BASE}/api/corpus/stats`).then(r => r.json()),
                    fetch(`${API_BASE}/api/sessions`).then(r => r.json())
                ]);

                document.getElementById('activeSessions').textContent = health.active_sessions;
                document.getElementById('totalSeeds').textContent = corpus.total_seeds;
                document.getElementById('totalFindings').textContent = corpus.total_findings;

                const totalTests = sessions.reduce((sum, s) => sum + s.total_tests, 0);
                document.getElementById('totalTests').textContent = totalTests.toLocaleString();
            } catch (error) {
                console.error('Failed to update stats:', error);
            }
        }

        // Show message
        function showMessage(text, type) {
            const div = document.createElement('div');
            div.className = type;
            div.textContent = text;
            document.getElementById('messages').appendChild(div);
            setTimeout(() => div.remove(), 8000);
        }

        // Polling
        let statsInterval;
        function startStatsPolling() {
            if (statsInterval) return;
            statsInterval = setInterval(() => {
                updateStats();
                loadSessions();
            }, 2000);
        }

        // Expose selected helpers globally for inline handlers
        window.switchTab = switchTab;
        window.showHelp = showHelp;
        window.closeHelp = closeHelp;
        window.toggleCheckbox = toggleCheckbox;
        window.startSession = startSession;
        window.stopSession = stopSession;
        window.deleteSession = deleteSession;

        // ========================================
        // Test Case Correlation Functions
        // ========================================

        let currentCorrelationSessionId = null;
        let timelineRefreshInterval = null;
        let selectedExecutionRecord = null;

        // Load sessions into correlation selector
        async function loadCorrelationSessions() {
            try {
                const response = await fetch(`${API_BASE}/api/sessions`);
                const sessions = await response.json();
                const select = document.getElementById('correlationSessionSelect');
                select.innerHTML = '<option value="">-- Select a session --</option>';

                // Sort by created_at descending (most recent first)
                sessions.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                sessions.forEach(session => {
                    const option = document.createElement('option');
                    option.value = session.id;
                    option.textContent = `${session.protocol} → ${session.target_host}:${session.target_port} (${session.status}) - ${new Date(session.created_at).toLocaleString()}`;
                    select.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to load sessions for correlation:', error);
            }
        }

        // Load selected session and start timeline refresh
        async function loadCorrelationSession() {
            const select = document.getElementById('correlationSessionSelect');
            currentCorrelationSessionId = select.value;

            if (!currentCorrelationSessionId) {
                document.getElementById('correlationSessionInfo').style.display = 'none';
                document.getElementById('timelineBody').innerHTML = '<tr><td colspan="8" style="padding: 20px; text-align: center; color: #888;">Select a session to view execution history</td></tr>';
                stopTimelineRefresh();
                return;
            }

            // Load session details
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}`);
                const session = await response.json();

                document.getElementById('corrSessionProtocol').textContent = session.protocol;
                document.getElementById('corrSessionTarget').textContent = `${session.target_host}:${session.target_port}`;
                document.getElementById('corrSessionStatus').textContent = session.status;
                document.getElementById('corrSessionTotal').textContent = session.total_tests;
                document.getElementById('correlationSessionInfo').style.display = 'block';

                // Load timeline
                await refreshTimeline();

                // Start auto-refresh if enabled
                if (document.getElementById('autoRefreshTimeline').checked) {
                    startTimelineRefresh();
                }
            } catch (error) {
                showMessage('Failed to load session details: ' + error.message, 'error');
            }
        }

        // Refresh execution timeline
        async function refreshTimeline() {
            if (!currentCorrelationSessionId) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}/execution_history?limit=100`);
                const data = await response.json();

                document.getElementById('timelineCount').textContent = data.returned_count;

                const tbody = document.getElementById('timelineBody');
                if (data.executions.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="8" style="padding: 20px; text-align: center; color: #888;">No executions recorded yet. Start the session to begin fuzzing.</td></tr>';
                    return;
                }

                // Reverse to show most recent first
                const executions = [...data.executions].reverse();

                tbody.innerHTML = executions.map(exec => {
                    const timeSent = new Date(exec.timestamp_sent).toLocaleTimeString('en-US', { hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit', fractionalSecondDigits: 3 });
                    const resultClass = exec.result === 'pass' ? 'badge-success' :
                                       exec.result === 'crash' ? 'badge-danger' :
                                       exec.result === 'hang' ? 'badge-warning' : 'badge-secondary';

                    return `
                        <tr style="border-bottom: 1px solid #333; cursor: pointer;" onmouseover="this.style.background='#2a2a2a'" onmouseout="this.style.background='transparent'" onclick="showExecutionDetail(${exec.sequence_number})">
                            <td style="padding: 10px;">#${exec.sequence_number}</td>
                            <td style="padding: 10px; font-family: monospace; font-size: 0.9em;">${timeSent}</td>
                            <td style="padding: 10px;">${exec.message_type || '-'}</td>
                            <td style="padding: 10px;">${exec.state_at_send || '-'}</td>
                            <td style="padding: 10px;"><span class="badge ${resultClass}">${exec.result}</span></td>
                            <td style="padding: 10px;">${exec.duration_ms.toFixed(2)}</td>
                            <td style="padding: 10px;">${exec.payload_size} bytes</td>
                            <td style="padding: 10px;">
                                <button onclick="event.stopPropagation(); showExecutionDetail(${exec.sequence_number})" style="background: #4caf50; border: none; color: white; padding: 4px 10px; border-radius: 3px; cursor: pointer; font-size: 0.85em;">
                                    View
                                </button>
                            </td>
                        </tr>
                    `;
                }).join('');
            } catch (error) {
                console.error('Failed to refresh timeline:', error);
                showMessage('Failed to refresh timeline: ' + error.message, 'error');
            }
        }

        // Start timeline auto-refresh
        function startTimelineRefresh() {
            stopTimelineRefresh();
            timelineRefreshInterval = setInterval(refreshTimeline, 2000);
        }

        // Stop timeline auto-refresh
        function stopTimelineRefresh() {
            if (timelineRefreshInterval) {
                clearInterval(timelineRefreshInterval);
                timelineRefreshInterval = null;
            }
        }

        // Toggle auto-refresh
        document.addEventListener('DOMContentLoaded', () => {
            const autoRefreshCheckbox = document.getElementById('autoRefreshTimeline');
            if (autoRefreshCheckbox) {
                autoRefreshCheckbox.addEventListener('change', (e) => {
                    if (e.target.checked && currentCorrelationSessionId) {
                        startTimelineRefresh();
                    } else {
                        stopTimelineRefresh();
                    }
                });
            }
        });

        // Find test case by timestamp
        async function findByTimestamp() {
            if (!currentCorrelationSessionId) {
                showMessage('Please select a session first', 'error');
                return;
            }

            const timestampInput = document.getElementById('searchTimestamp');
            if (!timestampInput.value) {
                showMessage('Please enter a timestamp', 'error');
                return;
            }

            // Convert to ISO 8601
            const timestamp = new Date(timestampInput.value).toISOString();

            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}/execution/at_time?timestamp=${encodeURIComponent(timestamp)}`);
                if (!response.ok) {
                    if (response.status === 404) {
                        showMessage('No test case found at that timestamp', 'error');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return;
                }
                const execution = await response.json();
                showMessage(`Found test case #${execution.sequence_number} at ${timestamp}`, 'success');
                showExecutionDetailData(execution);
            } catch (error) {
                showMessage('Failed to find test case: ' + error.message, 'error');
            }
        }

        // Find test case by sequence number
        async function findBySequence() {
            if (!currentCorrelationSessionId) {
                showMessage('Please select a session first', 'error');
                return;
            }

            const sequenceInput = document.getElementById('searchSequence');
            if (!sequenceInput.value) {
                showMessage('Please enter a sequence number', 'error');
                return;
            }

            const sequenceNumber = parseInt(sequenceInput.value);

            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}/execution/${sequenceNumber}`);
                if (!response.ok) {
                    if (response.status === 404) {
                        showMessage(`Test case #${sequenceNumber} not found`, 'error');
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return;
                }
                const execution = await response.json();
                showMessage(`Found test case #${execution.sequence_number}`, 'success');
                showExecutionDetailData(execution);
            } catch (error) {
                showMessage('Failed to find test case: ' + error.message, 'error');
            }
        }

        // Show execution detail by sequence number
        async function showExecutionDetail(sequenceNumber) {
            if (!currentCorrelationSessionId) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}/execution/${sequenceNumber}`);
                const execution = await response.json();
                showExecutionDetailData(execution);
            } catch (error) {
                showMessage('Failed to load test case details: ' + error.message, 'error');
            }
        }

        // Show execution detail modal with data
        function showExecutionDetailData(execution) {
            selectedExecutionRecord = execution;

            // Populate fields
            document.getElementById('detailSequence').textContent = execution.sequence_number;
            document.getElementById('detailId').textContent = execution.test_case_id;
            document.getElementById('detailTimeSent').textContent = new Date(execution.timestamp_sent).toLocaleString();
            document.getElementById('detailTimeResponse').textContent = execution.timestamp_response ? new Date(execution.timestamp_response).toLocaleString() : 'N/A';
            document.getElementById('detailDuration').textContent = execution.duration_ms.toFixed(2);

            const resultEl = document.getElementById('detailResult');
            resultEl.textContent = execution.result;
            resultEl.className = 'badge ' + (
                execution.result === 'pass' ? 'badge-success' :
                execution.result === 'crash' ? 'badge-danger' :
                execution.result === 'hang' ? 'badge-warning' : 'badge-secondary'
            );

            document.getElementById('detailProtocol').textContent = execution.protocol;
            document.getElementById('detailMessageType').textContent = execution.message_type || 'N/A';
            document.getElementById('detailState').textContent = execution.state_at_send || 'N/A';
            document.getElementById('detailHash').textContent = execution.payload_hash;
            document.getElementById('detailPayloadPreview').textContent = execution.payload_preview;
            document.getElementById('detailPayloadSize').textContent = execution.payload_size;

            // Response section
            if (execution.response_preview) {
                document.getElementById('detailResponsePreview').textContent = execution.response_preview;
                document.getElementById('detailResponseSize').textContent = execution.response_size || 0;
                document.getElementById('detailResponseSection').style.display = 'block';
            } else {
                document.getElementById('detailResponseSection').style.display = 'none';
            }

            document.getElementById('detailFullPayload').value = execution.raw_payload_b64;

            // Show modal
            document.getElementById('executionDetailModal').style.display = 'block';
        }

        // Close detail modal
        function closeDetailModal() {
            document.getElementById('executionDetailModal').style.display = 'none';
            selectedExecutionRecord = null;
        }

        // Copy full payload to clipboard
        function copyFullPayload() {
            const textarea = document.getElementById('detailFullPayload');
            textarea.select();
            document.execCommand('copy');
            showMessage('Payload copied to clipboard (Base64)', 'success');
        }

        // Replay single test case
        async function replaySingleTestCase() {
            if (!selectedExecutionRecord) {
                showMessage('No test case selected', 'error');
                return;
            }

            const sequenceNumber = selectedExecutionRecord.sequence_number;

            try {
                const response = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}/execution/replay`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sequence_numbers: [sequenceNumber],
                        delay_ms: 0
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                showMessage(`✓ Replayed test case #${sequenceNumber}. Result: ${result.results[0].result}`, 'success');

                // Refresh timeline to show replay
                await refreshTimeline();
            } catch (error) {
                showMessage('Failed to replay test case: ' + error.message, 'error');
            }
        }

        // Replay time range
        async function replayTimeRange() {
            if (!currentCorrelationSessionId) {
                showMessage('Please select a session first', 'error');
                return;
            }

            const startTimeInput = document.getElementById('replayStartTime');
            const endTimeInput = document.getElementById('replayEndTime');
            const delayInput = document.getElementById('replayDelay');

            if (!startTimeInput.value || !endTimeInput.value) {
                showMessage('Please enter both start and end times', 'error');
                return;
            }

            const startTime = new Date(startTimeInput.value).toISOString();
            const endTime = new Date(endTimeInput.value).toISOString();
            const delay = parseInt(delayInput.value) || 0;

            try {
                // First, fetch executions in time range
                const response = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}/execution_history?since=${encodeURIComponent(startTime)}&until=${encodeURIComponent(endTime)}&limit=1000`);
                const data = await response.json();

                if (data.executions.length === 0) {
                    showMessage('No test cases found in that time range', 'error');
                    return;
                }

                if (data.executions.length > 100) {
                    showMessage(`Warning: ${data.executions.length} test cases in range. Only replaying first 100.`, 'warning');
                }

                const sequenceNumbers = data.executions.slice(0, 100).map(e => e.sequence_number);

                // Show progress
                document.getElementById('replayProgress').style.display = 'block';
                document.getElementById('replayProgressBar').style.width = '0%';
                document.getElementById('replayProgressText').textContent = `Replaying ${sequenceNumbers.length} test cases...`;

                // Replay
                const replayResponse = await fetch(`${API_BASE}/api/sessions/${currentCorrelationSessionId}/execution/replay`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sequence_numbers: sequenceNumbers,
                        delay_ms: delay
                    })
                });

                if (!replayResponse.ok) {
                    throw new Error(`HTTP ${replayResponse.status}`);
                }

                const result = await replayResponse.json();

                // Update progress
                document.getElementById('replayProgressBar').style.width = '100%';
                document.getElementById('replayProgressText').textContent = `✓ Completed! Replayed ${result.replayed_count} test cases.`;

                // Count results
                const crashes = result.results.filter(r => r.result === 'crash').length;
                const hangs = result.results.filter(r => r.result === 'hang').length;
                const anomalies = result.results.filter(r => r.result === 'anomaly').length;

                let resultMsg = `Replayed ${result.replayed_count} test cases. `;
                if (crashes > 0) resultMsg += `${crashes} crashes, `;
                if (hangs > 0) resultMsg += `${hangs} hangs, `;
                if (anomalies > 0) resultMsg += `${anomalies} anomalies`;

                showMessage(resultMsg, crashes > 0 || hangs > 0 ? 'warning' : 'success');

                // Refresh timeline
                await refreshTimeline();

                // Hide progress after 3 seconds
                setTimeout(() => {
                    document.getElementById('replayProgress').style.display = 'none';
                }, 3000);

            } catch (error) {
                document.getElementById('replayProgress').style.display = 'none';
                showMessage('Failed to replay time range: ' + error.message, 'error');
            }
        }

        // Set current time in timestamp search
        function setCurrentTime() {
            const now = new Date();
            const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 23);
            document.getElementById('searchTimestamp').value = localDateTime;
        }

        // Load correlation sessions when tab is switched to correlation
        const originalSwitchTab = switchTab;
        switchTab = function(tabName, triggerEl) {
            originalSwitchTab(tabName, triggerEl);
            if (tabName === 'correlation') {
                loadCorrelationSessions();
            }
        };

        // ========================================
        // End Correlation Functions
        // ========================================

        // Initialize
        loadProtocols();
        loadSessions();
        updateStats();
        startStatsPolling();
        updateConfigurationCoach(null);

        // Show welcome message on first load
        if (!sessionStorage.getItem('welcomed')) {
            setTimeout(() => {
                showMessage('Welcome! Check the "Getting Started" tab for a tutorial, or create a session above to begin fuzzing.', 'info');
                sessionStorage.setItem('welcomed', 'true');
            }, 1000);
        }
    </script>
</body>
</html>
