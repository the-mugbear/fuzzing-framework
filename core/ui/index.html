<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proprietary Protocol Fuzzer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #888;
            font-size: 14px;
        }

        .help-btn {
            background: #444;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .help-btn:hover {
            background: #555;
        }

        .nav-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
        }

        .nav-tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .nav-tab.active {
            color: #0066cc;
            border-bottom-color: #0066cc;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .card {
            background: #252525;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }

        .card h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #fff;
        }

        .card-description {
            color: #888;
            font-size: 13px;
            line-height: 1.5;
            margin-bottom: 20px;
            padding: 10px;
            background: #1a1a1a;
            border-left: 3px solid #0066cc;
            border-radius: 4px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .help-icon {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: #444;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            cursor: help;
            color: #aaa;
        }

        .help-icon:hover {
            background: #0066cc;
            color: white;
        }

        .field-help {
            font-size: 12px;
            color: #666;
            margin-top: 3px;
            font-style: italic;
        }

        input, select {
            width: 100%;
            padding: 10px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 14px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #0066cc;
        }

        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        button:hover {
            background: #0052a3;
        }

        button:disabled {
            background: #444;
            cursor: not-allowed;
        }

        button.secondary {
            background: #444;
        }

        button.secondary:hover {
            background: #555;
        }

        button.danger {
            background: #cc0000;
        }

        button.danger:hover {
            background: #990000;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-idle { background: #444; }
        .status-running { background: #00aa00; animation: pulse 2s infinite; }
        .status-completed { background: #0066cc; }
        .status-failed { background: #cc0000; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .stat {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .stat-label {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        .session-item {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .session-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .session-info {
            flex-grow: 1;
        }

        .session-actions {
            display: flex;
            gap: 10px;
        }

        .session-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
        }

        .session-detail {
            font-size: 12px;
        }

        .session-detail-label {
            color: #666;
        }

        .session-detail-value {
            color: #fff;
            font-weight: 600;
        }

        .error {
            background: #cc0000;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .success {
            background: #00aa00;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .info {
            background: #0066cc;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .help-section {
            background: #252525;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .help-section h3 {
            color: #0066cc;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .help-section h4 {
            color: #fff;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .help-section p {
            color: #aaa;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .help-section ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        .help-section li {
            color: #aaa;
            margin-bottom: 8px;
            line-height: 1.5;
        }

        .code-block {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #0066cc;
            margin: 15px 0;
            overflow-x: auto;
        }

        .code-block pre {
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        .highlight {
            background: #0066cc;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 13px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
            background: #252525;
            border-radius: 8px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }

        .modal-title {
            font-size: 24px;
            color: #fff;
        }

        .modal-close {
            background: #444;
            border: none;
            color: #fff;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
        }

        .modal-close:hover {
            background: #cc0000;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -125px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .step-indicator {
            display: inline-block;
            width: 24px;
            height: 24px;
            background: #0066cc;
            border-radius: 50%;
            text-align: center;
            line-height: 24px;
            color: white;
            font-weight: bold;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div>
                <h1>Proprietary Protocol Fuzzer</h1>
                <p class="subtitle">Portable & Extensible Network Protocol Security Testing Framework</p>
            </div>
            <button class="help-btn" onclick="showHelp()">üìö Help & Guides</button>
        </header>

        <div id="messages"></div>

        <!-- Navigation Tabs -->
        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab('dashboard')">Dashboard</button>
            <button class="nav-tab" onclick="switchTab('help')">Getting Started</button>
            <button class="nav-tab" onclick="switchTab('protocol-guide')">Protocol Guide</button>
            <button class="nav-tab" onclick="switchTab('mutation-guide')">Mutation Guide</button>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard-tab" class="tab-content active">
            <div class="grid">
                <!-- Create Session -->
                <div class="card">
                    <h2>üöÄ Create Fuzzing Session</h2>
                    <div class="card-description">
                        <strong>Step 1:</strong> Configure your fuzzing campaign. Select a protocol plugin,
                        specify the target host and port, then create a session. The fuzzer will use the
                        protocol's seed corpus and mutation strategies to generate test cases.
                    </div>
                    <form id="createSessionForm">
                        <div class="form-group">
                            <label for="protocol">
                                Protocol Plugin
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Protocol plugins define the message structure (data model) and
                                        state machine for your target protocol. Custom plugins can be
                                        added to the core/plugins/ directory.
                                    </span>
                                </span>
                            </label>
                            <select id="protocol" required>
                                <option value="">Loading protocols...</option>
                            </select>
                            <div class="field-help">Choose a protocol that matches your target application</div>
                        </div>
                        <div class="form-group">
                            <label for="targetHost">
                                Target Host
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        Hostname or IP address of the target server.
                                        <br><br>
                                        <strong>Docker networking:</strong><br>
                                        ‚Ä¢ Use 'target' for SimpleTCP test server<br>
                                        ‚Ä¢ Use '172.17.0.1' (Linux) to reach host from container<br>
                                        ‚Ä¢ Use 'host.docker.internal' (Mac/Windows) to reach host<br>
                                        ‚Ä¢ 'localhost' only works if Core is NOT in Docker
                                    </span>
                                </span>
                            </label>
                            <input type="text" id="targetHost" value="target" required>
                            <div class="field-help">
                                <strong>Docker:</strong> Use 'target' for test server, or '172.17.0.1' to reach host.
                                <strong>Local:</strong> Use 'localhost' or IP address.
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="targetPort">
                                Target Port
                                <span class="tooltip">
                                    <span class="help-icon">?</span>
                                    <span class="tooltiptext">
                                        TCP port number where your target service is listening.
                                        Common ports: 80 (HTTP), 443 (HTTPS), 9999 (SimpleTCP test server).
                                    </span>
                                </span>
                            </label>
                            <input type="number" id="targetPort" value="9999" required min="1" max="65535">
                            <div class="field-help">Port number between 1-65535</div>
                        </div>
                        <button type="submit">Create Session</button>
                    </form>
                </div>

                <!-- System Status -->
                <div class="card">
                    <h2>üìä System Status</h2>
                    <div class="card-description">
                        <strong>Live Metrics:</strong> Real-time overview of fuzzing activity.
                        Active sessions show running fuzzing campaigns. Seeds are test inputs from
                        protocol plugins. Findings are potential vulnerabilities detected by the oracles.
                    </div>
                    <div class="stats">
                        <div class="stat tooltip">
                            <div class="stat-value" id="activeSessions">0</div>
                            <div class="stat-label">Active Sessions</div>
                            <span class="tooltiptext">
                                Number of fuzzing sessions currently running. Each session targets
                                a specific protocol/host combination and continuously generates
                                test cases. Multiple sessions can run concurrently.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalSeeds">0</div>
                            <div class="stat-label">Corpus Seeds</div>
                            <span class="tooltiptext">
                                Number of seed inputs in the corpus. Seeds are valid protocol messages
                                used as starting points for mutation. More diverse seeds = better
                                code coverage. Seeds come from protocol plugins or manual uploads.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalFindings">0</div>
                            <div class="stat-label">Findings</div>
                            <span class="tooltiptext">
                                Number of potential vulnerabilities discovered. Findings include
                                crashes, hangs, and logical failures. Each finding is saved with
                                full reproduction data in data/crashes/ directory. Findings are
                                persisted across restarts.
                            </span>
                        </div>
                        <div class="stat tooltip">
                            <div class="stat-value" id="totalTests">0</div>
                            <div class="stat-label">Total Tests</div>
                            <span class="tooltiptext">
                                Cumulative test cases executed across all sessions. Each test sends
                                one mutated input to the target. Higher numbers indicate more
                                thorough fuzzing. Typical rate: 100-1000 tests/sec depending on
                                target response time.
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Active Sessions -->
            <div class="card">
                <h2>üéØ Fuzzing Sessions</h2>
                <div class="card-description">
                    <strong>Session Management:</strong> Monitor and control your fuzzing campaigns. Each session
                    represents an independent fuzzing run targeting a specific protocol/host combination.
                    Click <strong>Start</strong> to begin sending mutated test cases to the target. The fuzzer
                    will continuously generate inputs using various mutation strategies and report any crashes,
                    hangs, or anomalies detected by the intelligent oracles.
                </div>
                <div id="sessions" class="loading">Loading sessions...</div>
            </div>
        </div>

        <!-- Help Tab -->
        <div id="help-tab" class="tab-content">
            <div class="help-section">
                <h3>üéì Getting Started with Protocol Fuzzing</h3>

                <h4><span class="step-indicator">1</span>Understanding the Dashboard</h4>
                <p>
                    The dashboard is your control center for fuzzing campaigns. Here's what each section does:
                </p>
                <ul>
                    <li><strong>Create Fuzzing Session:</strong> Configure a new fuzzing campaign by selecting a protocol, target host, and port.</li>
                    <li><strong>System Status:</strong> Real-time metrics showing active sessions, corpus size, findings, and total tests executed.</li>
                    <li><strong>Fuzzing Sessions:</strong> Manage running campaigns - start, stop, and monitor progress.</li>
                </ul>

                <h4><span class="step-indicator">2</span>Creating Your First Session</h4>
                <p>To start fuzzing:</p>
                <ul>
                    <li>Select a <strong>Protocol</strong> from the dropdown (e.g., "simple_tcp" for testing)</li>
                    <li>Enter the <strong>Target Host</strong> - use "target" for the Docker test server, or "localhost" for local testing</li>
                    <li>Specify the <strong>Target Port</strong> - the default SimpleTCP test server uses port 9999</li>
                    <li>Click <strong>"Create Session"</strong> to initialize the fuzzing campaign</li>
                    <li>Once created, click <strong>"Start"</strong> to begin fuzzing</li>
                </ul>

                <h4><span class="step-indicator">3</span>Monitoring Results</h4>
                <p>
                    As the fuzzer runs, watch for these key metrics:
                </p>
                <ul>
                    <li><strong>Tests:</strong> Number of mutated inputs sent to the target</li>
                    <li><strong>Crashes:</strong> Detected program crashes or connection failures</li>
                    <li><strong>Hangs:</strong> Timeouts indicating the target stopped responding</li>
                    <li><strong>Anomalies:</strong> Unexpected behavior detected by the validator oracles</li>
                </ul>

                <h4><span class="step-indicator">4</span>Understanding the Fuzzing Process</h4>
                <p>
                    The fuzzer operates in several stages:
                </p>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;"><strong>Seed Selection:</strong> The fuzzer starts with seed inputs from the protocol plugin</li>
                    <li style="margin-bottom: 10px;"><strong>Mutation:</strong> Multiple mutation strategies (bit flips, byte replacements, boundary values) create variations</li>
                    <li style="margin-bottom: 10px;"><strong>Execution:</strong> Mutated inputs are sent to the target via TCP connections</li>
                    <li style="margin-bottom: 10px;"><strong>Monitoring:</strong> Intelligent oracles watch for crashes, hangs, and logical failures</li>
                    <li style="margin-bottom: 10px;"><strong>Reporting:</strong> Findings are saved with full reproducers for analysis</li>
                </ol>

                <h4><span class="step-indicator">5</span>Testing with the SimpleTCP Server</h4>
                <p>
                    The included SimpleTCP test server has intentional vulnerabilities for demonstration:
                </p>
                <div class="code-block">
                    <pre># View target logs to see fuzzing in action
docker-compose logs -f target

# You'll see:
[+] Connection from (172.20.0.3, ...)
[-] Invalid magic: b'\x7f\xffCP'  ‚Üê Mutated headers
[+] Command: 0x91, Length: 4      ‚Üê Fuzzed commands</pre>
                </div>

                <h4><span class="step-indicator">6</span>Next Steps</h4>
                <ul>
                    <li>Check the <strong>"Protocol Guide"</strong> tab to learn how to create custom protocol plugins</li>
                    <li>Read the <strong>"Mutation Guide"</strong> tab to understand test case generation strategies</li>
                    <li>View <code>QUICKSTART.md</code> for Docker deployment and local testing instructions</li>
                    <li>Examine findings in the <code>data/crashes/</code> directory</li>
                </ul>
            </div>
        </div>

        <!-- Protocol Creation Guide Tab -->
        <div id="protocol-guide-tab" class="tab-content">
            <div class="help-section">
                <h3>üîß Creating Custom Protocol Plugins</h3>

                <p>
                    Protocol plugins are simple Python files that define your target protocol's structure and behavior.
                    The fuzzer uses this information to generate intelligent test cases.
                </p>

                <h4>Plugin Architecture</h4>
                <p>Each plugin consists of three main components:</p>
                <ul>
                    <li><strong>Data Model:</strong> Defines message structure (headers, fields, data types)</li>
                    <li><strong>State Model:</strong> Defines protocol state machine and transitions</li>
                    <li><strong>Validator (Optional):</strong> Custom logic to detect logical failures</li>
                </ul>

                <h4>Step 1: Create the Plugin File</h4>
                <p>Create a new file in <code>core/plugins/your_protocol.py</code>:</p>

                <div class="code-block">
                    <pre>"""
My Custom Protocol Plugin
Implements fuzzing for MyProtocol v1.0
"""

__version__ = "1.0.0"

# Required: Data Model
data_model = {
    "name": "MyProtocol",
    "description": "Custom protocol for MyApp",

    # Define message structure as blocks
    "blocks": [
        {
            "name": "magic",           # Field identifier
            "type": "bytes",           # Data type
            "size": 4,                 # Fixed size in bytes
            "default": b"MYPK",        # Default value
            "mutable": False           # Don't mutate (for magic headers)
        },
        {
            "name": "length",
            "type": "uint32",          # 32-bit unsigned integer
            "endian": "big",           # big or little endian
            "is_size_field": True,     # This field indicates data size
            "size_of": "payload"       # References another field
        },
        {
            "name": "command",
            "type": "uint8",           # 8-bit unsigned integer
            "values": {                # Known command codes
                0x01: "CONNECT",
                0x02: "DATA",
                0x03: "DISCONNECT"
            }
        },
        {
            "name": "payload",
            "type": "bytes",
            "max_size": 1024,          # Maximum size for mutation
            "default": b""
        }
    ],

    # Seed corpus: example messages for fuzzing
    "seeds": [
        b"MYPK\x00\x00\x00\x05\x01HELLO",
        b"MYPK\x00\x00\x00\x04\x02DATA",
        b"MYPK\x00\x00\x00\x00\x03"
    ]
}

# Required: State Model
state_model = {
    "initial_state": "INIT",

    # Define protocol states
    "states": ["INIT", "CONNECTED", "AUTHENTICATED", "CLOSED"],

    # Define state transitions
    "transitions": [
        {
            "from": "INIT",
            "to": "CONNECTED",
            "trigger": "connect",
            "message_type": "CONNECT",
            "expected_response": "CONNECT_OK"
        },
        {
            "from": "CONNECTED",
            "to": "AUTHENTICATED",
            "trigger": "authenticate",
            "message_type": "AUTH",
            "expected_response": "AUTH_OK"
        },
        {
            "from": "AUTHENTICATED",
            "to": "AUTHENTICATED",
            "trigger": "data_exchange",
            "message_type": "DATA"
        },
        {
            "from": "AUTHENTICATED",
            "to": "CLOSED",
            "trigger": "disconnect",
            "message_type": "DISCONNECT"
        }
    ]
}

# Optional: Custom Response Validator
def validate_response(response: bytes) -> bool:
    """
    Application-specific response validation.

    This is your "Specification Oracle" - check for logical
    errors that wouldn't cause a crash but violate protocol rules.

    Args:
        response: Raw response bytes from target

    Returns:
        True if response is valid, False if logical error detected

    Raises:
        ValueError: To flag as logical failure with description
    """
    if len(response) < 4:
        return False

    # Verify magic header
    if response[:4] != b"MYPK":
        return False

    # Example: Check for application-specific errors
    if len(response) > 8:
        command = response[8]

        # Error response should never happen in normal flow
        if command == 0xFF:
            return False

        # Check for impossible states
        # Example: Balance should never be negative in financial protocol
        # if response_type == "BALANCE" and parse_balance(response) < 0:
        #     raise ValueError("Negative balance detected - logic bug!")

    return True</pre>
                </div>

                <h4>Step 2: Field Types Reference</h4>
                <p>Available field types for the data model:</p>
                <ul>
                    <li><code>bytes</code> - Raw byte array (requires <code>size</code> or <code>max_size</code>)</li>
                    <li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> - Unsigned integers</li>
                    <li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> - Signed integers</li>
                    <li><code>string</code> - UTF-8 text (specify <code>encoding</code>)</li>
                </ul>

                <h4>Step 3: Advanced Features</h4>
                <p>Mark fields for special handling:</p>
                <ul>
                    <li><code>mutable: False</code> - Prevent fuzzer from mutating this field (use for magic headers)</li>
                    <li><code>is_size_field: True</code> - This field specifies another field's length</li>
                    <li><code>size_of: "fieldname"</code> - Link size field to data field</li>
                    <li><code>values: {}</code> - Dictionary of known/valid values for documentation</li>
                </ul>

                <h4>Step 4: Load and Test Your Plugin</h4>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;">Save your plugin file in <code>core/plugins/your_protocol.py</code></li>
                    <li style="margin-bottom: 10px;">Restart the Core: <code>docker-compose restart core</code></li>
                    <li style="margin-bottom: 10px;">Refresh this page and your protocol should appear in the dropdown</li>
                    <li style="margin-bottom: 10px;">Create a session and start fuzzing!</li>
                </ol>

                <h4>Tips for Effective Plugins</h4>
                <ul>
                    <li><strong>Start Simple:</strong> Begin with basic message structure, add complexity later</li>
                    <li><strong>Use Good Seeds:</strong> Provide 3-5 valid message examples in different states</li>
                    <li><strong>Document Everything:</strong> Use comments and docstrings liberally</li>
                    <li><strong>Test Incrementally:</strong> Run short fuzzing sessions after each change</li>
                    <li><strong>Learn from Examples:</strong> Study <code>core/plugins/simple_tcp.py</code></li>
                </ul>

                <h4>Validator Best Practices</h4>
                <p>
                    The validator function is powerful for catching logical bugs:
                </p>
                <ul>
                    <li>Return <code>False</code> for invalid responses (logged as anomalies)</li>
                    <li>Raise <code>ValueError</code> with message for serious logic bugs</li>
                    <li>Check business logic: negative balances, invalid timestamps, wrong sequences</li>
                    <li>Verify protocol invariants: authenticated actions require auth, etc.</li>
                    <li>Keep it fast - this runs on every test case</li>
                </ul>

                <h4>Example: Financial Protocol</h4>
                <div class="code-block">
                    <pre>def validate_response(response: bytes) -> bool:
    """Check financial protocol responses"""
    if len(response) < 10:
        return False

    msg_type = response[8]

    # Check for balance query response
    if msg_type == 0x20:  # BALANCE_RESPONSE
        # Parse balance (big-endian int64 at offset 9)
        balance = int.from_bytes(response[9:17], 'big', signed=True)

        # This should NEVER happen - logic bug!
        if balance < 0:
            raise ValueError(f"Negative balance returned: {balance}")

    return True</pre>
                </div>
            </div>
        </div>

        <!-- Mutation Strategy Guide Tab -->
        <div id="mutation-guide-tab" class="tab-content">
            <div class="help-section">
                <h3>üß¨ Understanding Mutation Strategies</h3>

                <p>
                    The fuzzer generates test cases using multiple mutation strategies. Each strategy
                    targets different vulnerability classes and code paths.
                </p>

                <h4>1. Bit Flip Mutation</h4>
                <p><strong>Purpose:</strong> Find vulnerabilities in bit-level data handling</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Randomly flips individual bits in the input (0‚Üí1, 1‚Üí0)</li>
                    <li>Flips ~1% of all bits by default</li>
                    <li>Creates subtle corruption that may bypass validation</li>
                </ul>
                <p><strong>Targets:</strong> Checksum errors, bit flag handling, encoding issues</p>
                <div class="code-block">
                    <pre>Example:
Original: 01001000 01100101 (He)
Mutated:  01001001 01100101 (Ie) ‚Üê One bit flipped</pre>
                </div>

                <h4>2. Byte Flip Mutation</h4>
                <p><strong>Purpose:</strong> Test boundary values and character handling</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Replaces ~5% of bytes with random values</li>
                    <li>More aggressive than bit flipping</li>
                    <li>Can create invalid characters or protocol markers</li>
                </ul>
                <p><strong>Targets:</strong> Character encoding bugs, parser errors, magic number validation</p>

                <h4>3. Arithmetic Mutation</h4>
                <p><strong>Purpose:</strong> Trigger integer overflow and underflow vulnerabilities</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Treats 4-byte sequences as integers</li>
                    <li>Adds or subtracts small values: -128, -64, -16, -1, 1, 16, 64, 128</li>
                    <li>Can cause wraparound at MAX_INT boundaries</li>
                </ul>
                <p><strong>Targets:</strong> Buffer size calculations, loop counters, array indices</p>
                <div class="code-block">
                    <pre>Example:
Original length: 1024 (0x00000400)
Mutated length:  1152 (0x00000480) ‚Üê Added 128
Effect: May cause buffer overflow if buffer is 1024 bytes</pre>
                </div>

                <h4>4. Interesting Values Mutation</h4>
                <p><strong>Purpose:</strong> Test boundary conditions and edge cases</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Replaces integers with known "interesting" boundary values</li>
                    <li>8-bit: 0, 1, 127, 128, 255</li>
                    <li>16-bit: 0, 1, 255, 256, 32767, 32768, 65535</li>
                    <li>32-bit: 0, 1, 65535, 65536, MAX_INT-1, MAX_INT, MAX_INT+1</li>
                </ul>
                <p><strong>Targets:</strong> Off-by-one errors, signedness bugs, type confusion</p>
                <p><strong>Why these values?</strong></p>
                <ul>
                    <li><code>0</code> - Often causes division by zero or null pointer</li>
                    <li><code>-1 (0xFF...)</code> - Common error return value, max unsigned</li>
                    <li><code>127/128</code> - Signed/unsigned byte boundary</li>
                    <li><code>32767/32768</code> - Signed/unsigned short boundary</li>
                    <li><code>65535/65536</code> - 16-bit max / 17-bit min</li>
                </ul>

                <h4>5. Havoc Mutation</h4>
                <p><strong>Purpose:</strong> Aggressive exploration of input space</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Applies 2-10 random mutations in sequence:
                        <ul style="margin-left: 20px; margin-top: 5px;">
                            <li><strong>Insert:</strong> Add random bytes at random position</li>
                            <li><strong>Delete:</strong> Remove random bytes</li>
                            <li><strong>Duplicate:</strong> Copy chunk and insert elsewhere</li>
                            <li><strong>Shuffle:</strong> Randomize byte order in a chunk</li>
                        </ul>
                    </li>
                    <li>Can drastically change input structure</li>
                    <li>Good for finding unexpected code paths</li>
                </ul>
                <p><strong>Targets:</strong> Parser robustness, state machine errors, memory corruption</p>

                <h4>6. Splice Mutation</h4>
                <p><strong>Purpose:</strong> Combine features from different seeds</p>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Takes two different seed inputs</li>
                    <li>Splits each at a random position</li>
                    <li>Combines first half of seed A with second half of seed B</li>
                </ul>
                <p><strong>Targets:</strong> State confusion, context mixing, protocol sequence bugs</p>
                <div class="code-block">
                    <pre>Example:
Seed A: [AUTH_REQUEST][username=alice][password=pass123]
Seed B: [DATA_REQUEST][query=SELECT * FROM users]
Splice: [AUTH_REQUEST][username=alice][query=SELECT * FROM users]
Result: Authentication message with SQL query - may bypass checks!</pre>
                </div>

                <h4>Strategy Selection</h4>
                <p>The fuzzer uses weighted random selection for mutation strategies:</p>
                <ul>
                    <li>Bit Flip: 20%</li>
                    <li>Byte Flip: 20%</li>
                    <li>Arithmetic: 15%</li>
                    <li>Interesting Values: 20%</li>
                    <li>Havoc: 15%</li>
                    <li>Splice: 10%</li>
                </ul>

                <h4>Mutation Pipeline</h4>
                <p>For each test case:</p>
                <ol style="margin-left: 40px; color: #aaa;">
                    <li style="margin-bottom: 10px;">Select a seed from the corpus</li>
                    <li style="margin-bottom: 10px;">Choose a mutation strategy (weighted random)</li>
                    <li style="margin-bottom: 10px;">Apply 1-5 mutation passes</li>
                    <li style="margin-bottom: 10px;">Send mutated input to target</li>
                    <li style="margin-bottom: 10px;">Monitor for crashes/anomalies</li>
                    <li style="margin-bottom: 10px;">Repeat</li>
                </ol>

                <h4>Vulnerability Classes Targeted</h4>
                <div class="code-block">
                    <pre><strong>Memory Corruption:</strong>
  ‚Ä¢ Buffer overflows (arithmetic + havoc)
  ‚Ä¢ Heap corruption (havoc + splice)
  ‚Ä¢ Use-after-free (splice + interesting values)

<strong>Integer Issues:</strong>
  ‚Ä¢ Integer overflow/underflow (arithmetic)
  ‚Ä¢ Signed/unsigned confusion (interesting values)
  ‚Ä¢ Type confusion (interesting values + splice)

<strong>Logic Bugs:</strong>
  ‚Ä¢ State machine errors (splice + havoc)
  ‚Ä¢ Authentication bypass (splice)
  ‚Ä¢ Input validation bypass (bit flip + byte flip)

<strong>Parser Errors:</strong>
  ‚Ä¢ Invalid UTF-8 sequences (byte flip)
  ‚Ä¢ Malformed structures (havoc)
  ‚Ä¢ Wrong endianness (bit flip + arithmetic)</pre>
                </div>

                <h4>Advanced: Guided Fuzzing (Phase 2+)</h4>
                <p>Future versions will add:</p>
                <ul>
                    <li><strong>Coverage-Guided:</strong> Prioritize mutations that find new code paths</li>
                    <li><strong>Dictionary-Based:</strong> Insert protocol keywords and constants</li>
                    <li><strong>Structural:</strong> Respect protocol grammar while mutating values</li>
                    <li><strong>Taint-Guided:</strong> Track data flow to mutate effective fields</li>
                </ul>

                <h4>Tips for Effective Fuzzing</h4>
                <ul>
                    <li><strong>Good Seeds Matter:</strong> Provide valid, diverse seed inputs</li>
                    <li><strong>Target Specific Fields:</strong> Use data model to guide mutations</li>
                    <li><strong>Run Long Campaigns:</strong> Many bugs require thousands of iterations</li>
                    <li><strong>Monitor Findings:</strong> Check crash reports regularly</li>
                    <li><strong>Iterate:</strong> Update seeds based on findings</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Help & Documentation</h2>
                <button class="modal-close" onclick="closeHelp()">√ó</button>
            </div>
            <div>
                <h3 style="color: #0066cc; margin-bottom: 15px;">Quick Links</h3>
                <ul style="margin-left: 20px; line-height: 2;">
                    <li><a href="#" onclick="switchTab('help'); closeHelp(); return false;" style="color: #0066cc;">Getting Started Guide</a></li>
                    <li><a href="#" onclick="switchTab('protocol-guide'); closeHelp(); return false;" style="color: #0066cc;">Create Custom Protocol Plugins</a></li>
                    <li><a href="#" onclick="switchTab('mutation-guide'); closeHelp(); return false;" style="color: #0066cc;">Understand Mutation Strategies</a></li>
                </ul>

                <h3 style="color: #0066cc; margin-top: 30px; margin-bottom: 15px;">External Documentation</h3>
                <ul style="margin-left: 20px; line-height: 2; color: #aaa;">
                    <li><code>QUICKSTART.md</code> - Setup and deployment guide</li>
                    <li><code>CHEATSHEET.md</code> - Quick reference for commands</li>
                    <li><code>blueprint.md</code> - Architecture and design</li>
                    <li><code>roadmap.md</code> - Development phases</li>
                </ul>

                <h3 style="color: #0066cc; margin-top: 30px; margin-bottom: 15px;">Support</h3>
                <p style="color: #aaa; margin-bottom: 10px;">
                    Check Docker logs for debugging:
                </p>
                <div class="code-block">
                    <pre># View all services
docker-compose logs -f

# View specific service
docker-compose logs -f core
docker-compose logs -f target</pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000';

        // Tab Management
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            event.target.classList.add('active');
        }

        // Modal Management
        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        // Close modal on background click
        document.getElementById('helpModal').addEventListener('click', (e) => {
            if (e.target.id === 'helpModal') {
                closeHelp();
            }
        });

        // Load protocols on page load
        async function loadProtocols() {
            try {
                const response = await fetch(`${API_BASE}/api/plugins`);
                const protocols = await response.json();
                const select = document.getElementById('protocol');
                select.innerHTML = protocols.map(p =>
                    `<option value="${p}">${p}</option>`
                ).join('');
            } catch (error) {
                showMessage('Failed to load protocols: ' + error.message, 'error');
            }
        }

        // Create session
        document.getElementById('createSessionForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const config = {
                protocol: document.getElementById('protocol').value,
                target_host: document.getElementById('targetHost').value,
                target_port: parseInt(document.getElementById('targetPort').value)
            };

            try {
                const response = await fetch(`${API_BASE}/api/sessions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(config)
                });

                if (response.ok) {
                    const session = await response.json();
                    showMessage(`‚úì Session created successfully! Click "Start" to begin fuzzing.`, 'success');
                    loadSessions();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to create session: ' + error.message, 'error');
            }
        });

        // Load sessions
        async function loadSessions() {
            try {
                const response = await fetch(`${API_BASE}/api/sessions`);
                const sessions = await response.json();

                const container = document.getElementById('sessions');
                if (sessions.length === 0) {
                    container.innerHTML = '<p class="loading">No active sessions. Create one above to get started!</p>';
                } else {
                    container.innerHTML = sessions.map(s => `
                        <div class="session-item">
                            <div class="session-header">
                                <div class="session-info">
                                    <strong>${s.protocol}</strong> ‚Üí ${s.target_host}:${s.target_port}
                                    <br>
                                    <span class="status-badge status-${s.status}">${s.status}</span>
                                    <small style="color: #888; margin-left: 10px;">
                                        ${s.status === 'running' ? 'üîÑ Actively fuzzing...' :
                                          s.status === 'idle' ? '‚è∏Ô∏è Ready to start' :
                                          s.status === 'completed' ? '‚úì Session completed' :
                                          s.status === 'failed' ? '‚ùå Session failed' : ''}
                                    </small>
                                </div>
                                <div class="session-actions">
                                    ${s.status === 'idle' ?
                                        `<button onclick="startSession('${s.id}')" title="Start sending fuzzed inputs to target">‚ñ∂Ô∏è Start</button>` :
                                        s.status === 'running' ?
                                        `<button class="danger" onclick="stopSession('${s.id}')" title="Stop fuzzing campaign">‚èπÔ∏è Stop</button>` :
                                        s.status === 'failed' ?
                                        `<button class="secondary" onclick="deleteSession('${s.id}')" title="Remove this session">üóëÔ∏è Delete</button>` :
                                        ''
                                    }
                                </div>
                            </div>
                            ${s.error_message ? `
                                <div class="error" style="margin-top: 10px; font-size: 13px;">
                                    <strong>‚ö†Ô∏è Error:</strong> ${s.error_message}
                                </div>
                            ` : ''}
                            <div class="session-details">
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Total Tests</div>
                                    <div class="session-detail-value">${s.total_tests.toLocaleString()}</div>
                                    <span class="tooltiptext">
                                        Number of mutated inputs sent to target in this session.
                                        Each test applies mutation strategies (bit flip, arithmetic, etc.)
                                        to seed corpus. More tests = more thorough fuzzing.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Crashes</div>
                                    <div class="session-detail-value" style="color: ${s.crashes > 0 ? '#cc0000' : '#fff'}">${s.crashes}</div>
                                    <span class="tooltiptext">
                                        Program crashes detected. Includes connection failures,
                                        segmentation faults, and abnormal terminations. Each crash
                                        is a potential security vulnerability. Saved in data/crashes/.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Hangs</div>
                                    <div class="session-detail-value" style="color: ${s.hangs > 0 ? '#ff9900' : '#fff'}">${s.hangs}</div>
                                    <span class="tooltiptext">
                                        Timeout events where target stopped responding. May indicate
                                        infinite loops, deadlocks, or resource exhaustion. Timeout
                                        threshold: 5 seconds (configurable). Can lead to DoS.
                                    </span>
                                </div>
                                <div class="session-detail tooltip">
                                    <div class="session-detail-label">Anomalies</div>
                                    <div class="session-detail-value" style="color: ${s.anomalies > 0 ? '#ffcc00' : '#fff'}">${s.anomalies}</div>
                                    <span class="tooltiptext">
                                        Logical failures detected by validator oracles. Target
                                        didn't crash but returned invalid/unexpected responses.
                                        Examples: negative balance, wrong state, invalid format.
                                        Check validator in protocol plugin.
                                    </span>
                                </div>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (error) {
                document.getElementById('sessions').innerHTML =
                    `<p class="error">Failed to load sessions: ${error.message}</p>`;
            }
        }

        // Start session
        async function startSession(sessionId) {
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${sessionId}/start`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showMessage('‚úì Fuzzing started! Monitor the statistics below.', 'success');
                    loadSessions();
                    startStatsPolling();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to start session: ' + error.message, 'error');
            }
        }

        // Stop session
        async function stopSession(sessionId) {
            try {
                const response = await fetch(`${API_BASE}/api/sessions/${sessionId}/stop`, {
                    method: 'POST'
                });

                if (response.ok) {
                    showMessage('‚úì Fuzzing session stopped. Check findings in data/crashes/.', 'info');
                    loadSessions();
                } else {
                    throw new Error(await response.text());
                }
            } catch (error) {
                showMessage('Failed to stop session: ' + error.message, 'error');
            }
        }

        // Delete session
        async function deleteSession(sessionId) {
            if (!confirm('Are you sure you want to delete this session? This action cannot be undone.')) {
                return;
            }

            // For now, just hide it from UI (full implementation would call DELETE endpoint)
            showMessage('Session removed from view. Refresh page to see all sessions.', 'info');
            loadSessions();
        }

        // Update system stats
        async function updateStats() {
            try {
                const [health, corpus, sessions] = await Promise.all([
                    fetch(`${API_BASE}/api/system/health`).then(r => r.json()),
                    fetch(`${API_BASE}/api/corpus/stats`).then(r => r.json()),
                    fetch(`${API_BASE}/api/sessions`).then(r => r.json())
                ]);

                document.getElementById('activeSessions').textContent = health.active_sessions;
                document.getElementById('totalSeeds').textContent = corpus.total_seeds;
                document.getElementById('totalFindings').textContent = corpus.total_findings;

                const totalTests = sessions.reduce((sum, s) => sum + s.total_tests, 0);
                document.getElementById('totalTests').textContent = totalTests.toLocaleString();
            } catch (error) {
                console.error('Failed to update stats:', error);
            }
        }

        // Show message
        function showMessage(text, type) {
            const div = document.createElement('div');
            div.className = type;
            div.textContent = text;
            document.getElementById('messages').appendChild(div);
            setTimeout(() => div.remove(), 8000);
        }

        // Polling
        let statsInterval;
        function startStatsPolling() {
            if (statsInterval) return;
            statsInterval = setInterval(() => {
                updateStats();
                loadSessions();
            }, 2000);
        }

        // Initialize
        loadProtocols();
        loadSessions();
        updateStats();
        startStatsPolling();

        // Show welcome message on first load
        if (!sessionStorage.getItem('welcomed')) {
            setTimeout(() => {
                showMessage('üëã Welcome! Check the "Getting Started" tab for a tutorial, or create a session above to begin fuzzing.', 'info');
                sessionStorage.setItem('welcomed', 'true');
            }, 1000);
        }
    </script>
</body>
</html>
